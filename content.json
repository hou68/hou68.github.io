{"meta":{"title":"个人空间","subtitle":null,"description":null,"author":"joke","url":"http://yoursite.com"},"pages":[{"title":"","date":"2018-02-27T15:27:07.971Z","updated":"2018-02-27T15:27:07.971Z","comments":true,"path":"about/index.html","permalink":"http://yoursite.com/about/index.html","excerpt":"","text":"layout: aboutcomments: truereward: false"},{"title":"","date":"2018-02-27T15:26:27.066Z","updated":"2018-02-27T15:26:27.066Z","comments":true,"path":"tags/index.html","permalink":"http://yoursite.com/tags/index.html","excerpt":"","text":"layout: tagscomments: false"}],"posts":[{"title":"HashMap","slug":"java","date":"2018-03-07T15:21:38.028Z","updated":"2018-03-11T15:27:17.403Z","comments":true,"path":"2018/03/07/java/","link":"","permalink":"http://yoursite.com/2018/03/07/java/","excerpt":"","text":"HashMap一、HashMap实现原理&emsp;&emsp;HashMap是基于哈希表实现的，每一个元素都是key-value对，其内部是通过单链表结构解决内部冲突问题,当容量不足的时候，会通过自动增长来解决这个问题&emsp;&emsp;HashMap是非线程安全的，所以用于单线程环境下,多线程环境下可以采用concurrent并发包下的concurrentHashMap。&emsp;&emsp;HashMap实现了Serializable接口，因此它支持序列化，实现了Cloneable接口，能被克隆。&emsp;&emsp;HashMap由数组+链表组成的，数组是HashMap的主体，链表则是主要为了解决哈希冲突而存在的，如果定位到的数组位置不含链表（当前entry的next指向null）,那么对于查找，添加等操作很快，仅需一次寻址即可；如果定位到的数组包含链表，对于添加操作，其时间复杂度依然为O(1)，因为最新的Entry会插入链表头部，只需要简单的改变引用链，而对于查找操作来讲，此时就需要遍历链表，然后通过key对象的equals方法逐一对比。所以从性能方面考虑，HashMap中的链表出现越少，性能才会越好。&emsp;&emsp;链表中节点的数据结构：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071// Entry是单向链表。 // 它是 “HashMap链式存储法”对应的链表。 // 它实现了Map.Entry 接口，即实现getKey(), getValue(), setValue(V value), equals(Object o), hashCode()这些函数 static class Entry&lt;K,V&gt; implements Map.Entry&lt;K,V&gt; &#123; final K key; V value; // 指向下一个节点 Entry&lt;K,V&gt; next; final int hash; // 构造函数。 // 输入参数包括&quot;哈希值(h)&quot;, &quot;键(k)&quot;, &quot;值(v)&quot;, &quot;下一节点(n)&quot; Entry(int h, K k, V v, Entry&lt;K,V&gt; n) &#123; value = v; next = n; key = k; hash = h; &#125; public final K getKey() &#123; return key; &#125; public final V getValue() &#123; return value; &#125; public final V setValue(V newValue) &#123; V oldValue = value; value = newValue; return oldValue; &#125; // 判断两个Entry是否相等 // 若两个Entry的“key”和“value”都相等，则返回true。 // 否则，返回false public final boolean equals(Object o) &#123; if (!(o instanceof Map.Entry)) return false; Map.Entry e = (Map.Entry)o; Object k1 = getKey(); Object k2 = e.getKey(); if (k1 == k2 || (k1 != null &amp;&amp; k1.equals(k2))) &#123; Object v1 = getValue(); Object v2 = e.getValue(); if (v1 == v2 || (v1 != null &amp;&amp; v1.equals(v2))) return true; &#125; return false; &#125; // 实现hashCode() public final int hashCode() &#123; return (key==null ? 0 : key.hashCode()) ^ (value==null ? 0 : value.hashCode()); &#125; public final String toString() &#123; return getKey() + &quot;=&quot; + getValue(); &#125; // 当向HashMap中添加元素时，绘调用recordAccess()。 // 这里不做任何处理 void recordAccess(HashMap&lt;K,V&gt; m) &#123; &#125; // 当从HashMap中删除元素时，绘调用recordRemoval()。 // 这里不做任何处理 void recordRemoval(HashMap&lt;K,V&gt; m) &#123; &#125; &#125; &emsp;&emsp; 它的结构元素除了key、value、hash外，还有next，next指向下一个节点。另外，这里覆写了equals和hashCode方法来保证键值对的独一无二。 二、HashMap是怎么扩容的，简介加载因子&emsp;&emsp;HashMap共有四个构造方法。构造方法中提到了两个很重要的参数：初始容量和加载因子。这两个参数是影响HashMap性能的重要参数，其中容量表示哈希表中槽的数量（即哈希数组的长度），初始容量是创建哈希表时的容量（从构造函数中可以看出，如果不指明，则默认为16），加载因子是哈希表在其容量自动增加之前可以达到多满的一种尺度，当哈希表中的条目数超出了加载因子与当前容量的乘积时，则要对该哈希表进行 resize 操作（即扩容）。&emsp;&emsp;如果加载因子越大，对空间的利用更充分，但是查找效率会降低（链表长度会越来越长）；如果加载因子太小，那么表中的数据将过于稀疏（很多空间还没用，就开始扩容了），对空间造成严重浪费。如果我们在构造方法中不指定，则系统默认加载因子为0.75，这是一个比较理想的值，一般情况下我们是无需修改的。另外无论我们指定的容量为多少，构造方法都会将实际容量设为不小于指定容量的2的次方的一个数，且最大值不能超过2的30次方 三、jdk8对hashmap做了什么优化&emsp;&emsp;在JDK1.8版本中，对数据结构做了进一步的优化，引入了红黑树。而当链表长度太长（默认超过8）时，链表就转换为红黑树，利用红黑树快速增删改查的特点提高HashMap的性能，其中会用到红黑树的插入、删除、查找等算法 四、HashMap在高并发下如果没有处理线程安全会有什么的安全隐患&emsp;&emsp;HashMap事实上并非线程安全的，在高并发的情况下，是非常可能发生死循环的，由此造成CPU 100%，这是非常可怕的。所以在多线程的情况下，用HashMap是非常不妥当的行为，应采用线程安全类ConcurrentHashMap进行取代。","categories":[],"tags":[]},{"title":"Hello World","slug":"hello-world","date":"2018-02-26T15:47:51.992Z","updated":"2018-02-28T12:44:24.504Z","comments":true,"path":"2018/02/26/hello-world/","link":"","permalink":"http://yoursite.com/2018/02/26/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment Create a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment Create a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment Create a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}]}