<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>个人空间</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2018-03-14T15:31:17.836Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>joke</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Spring Security based on Spring Boot</title>
    <link href="http://yoursite.com/2018/03/14/spring-security/"/>
    <id>http://yoursite.com/2018/03/14/spring-security/</id>
    <published>2018-03-14T15:28:22.677Z</published>
    <updated>2018-03-14T15:31:17.836Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to Wuwei`Blog</p><h1 id="Spring-Security-based-on-Spring-Boot"><a href="#Spring-Security-based-on-Spring-Boot" class="headerlink" title="Spring Security based on Spring Boot"></a>Spring Security based on Spring Boot</h1><hr><h2 id="一-基础篇"><a href="#一-基础篇" class="headerlink" title="一 基础篇"></a>一 基础篇</h2><h3 id="Spring-security-是什么？"><a href="#Spring-security-是什么？" class="headerlink" title="Spring security 是什么？"></a>Spring security 是什么？</h3><p>&emsp;&emsp;Spring Security是一个能够为基于Spring的企业应用系统提供声明式的安全访问控制解决方案的安全框架。<br>它提供了一组可以在Spring应用上下文中配置的Bean，充分利用了Spring IoC，DI（控制反转Inversion of Control ,DI:Dependency Injection 依赖注入）和AOP（面向切面编程）功能，为应用系统提供声明式的安全访问控制功能，减少了为企业系统安全控制编写大量重复代码的工作。</p><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><blockquote><p>详细的请看高级篇过滤器详解</p></blockquote><p>&emsp;&emsp;Spring Security对Web安全性的支持大量地依赖于Servlet过滤器。通过这些过滤器拦截进入请求，判断是否已经登录认证且具访问对应请求的权限,要完成访问控制，Spring Security至少需要下面四个拦截器（调度器、认证管理器、权限资源关联器、访问决策器）进行配合完成.<br>&emsp;&emsp;使用众多的拦截器对url拦截，以此来管理权限，主要讲里面核心流程的两个。 首先，权限管理离不开登陆验证的，所以登陆验证拦截器AuthenticationProcessingFilter要讲； 还有就是对访问的资源管理吧，所以资源管理拦截器AbstractSecurityInterceptor要讲； 但拦截器里面的实现需要一些组件来实现，所以就有了AuthenticationManager、accessDecisionManager等组件来支撑。<br>&emsp;&emsp;现在先大概过一遍整个流程，用户登陆，会被AuthenticationProcessingFilter拦截，调用AuthenticationManager的实现，而且AuthenticationManager会调用ProviderManager来获取用户验证信息（不同的Provider调用的服务不同，因为这些信息可以是在数据库上，可以是在LDAP服务器上，可以是xml配置文件上等），如果验证通过后会将用户的权限信息封装一个User放到spring的全局缓存SecurityContextHolder中，以备后面访问资源时使用。 访问资源（即授权管理），访问url时，会通过AbstractSecurityInterceptor拦截器拦截，其中会调用FilterInvocationSecurityMetadataSource的方法来获取被拦截url所需的全部权限，在调用授权管理器AccessDecisionManager，这个授权管理器会通过spring的全局缓存SecurityContextHolder获取用户的权限信息，还会获取被拦截的url和被拦截url所需的全部权限，然后根据所配的策略（有：一票决定，一票否定，少数服从多数等），如果权限足够，则返回，权限不够则报错并调用权限不足页面。     虽然讲得好像好复杂，读者们可能有点晕，不过不打紧，真正通过代码的讲解在后面，读者可以看完后面的代码实现，再返回看这个简单的原理，可能会有不错的收获。</p><h3 id="分类"><a href="#分类" class="headerlink" title="分类:"></a>分类:</h3><p>&emsp;&emsp;总共有四种用法，从简到深为：1、不用数据库，全部数据写在配置文件，这个也是官方文档里面的demo(一般生产环境用不到，仅做参考。)；2、使用数据库，根据spring security默认实现代码设计数据库，也就是说数据库已经固定了，这种方法不灵活，而且那个数据库设计得很简陋，实用性差；3、spring security和Acegi不同，它不能修改默认filter了，但支持插入filter，所以根据这个，我们可以插入自己的filter来灵活使用；4、暴力手段，修改源码，前面说的修改默认filter只是修改配置文件以替换filter而已，这种是直接改了里面的源码，但是这种不符合OO设计原则，而且不实际，不可用。</p><h3 id="核心组件"><a href="#核心组件" class="headerlink" title="核心组件"></a>核心组件</h3><h4 id="1-SecurityContextHolder"><a href="#1-SecurityContextHolder" class="headerlink" title="1 SecurityContextHolder"></a>1 SecurityContextHolder</h4><p>&emsp;&emsp;SecurityContextHolder用于存储安全上下文（security context）的信息。当前操作的用户是谁，该用户是否已经被认证，他拥有哪些角色权限等，这些都被保存在SecurityContextHolder中。SecurityContextHolder默认使用ThreadLocal策略来存储认证信息。看到ThreadLocal 也就意味着，这是一种与线程绑定的策略。Spring Security在用户登录时自动绑定认证信息到当前线程，在用户退出时，自动清除当前线程的认证信息。但这一切的前提，是你在web场景下使用Spring Security，而如果是Swing界面，Spring也提供了支持，SecurityContextHolder的策略则需要被替换，鉴于我的初衷是基于web来介绍Spring Security，所以这里以及后续，非web的相关的内容都一笔带过。</p><h5 id="1-1-获取当前用户的信息"><a href="#1-1-获取当前用户的信息" class="headerlink" title="1.1 获取当前用户的信息"></a>1.1 获取当前用户的信息</h5><p>&emsp;&emsp;因为身份信息是与线程绑定的，所以可以在程序的任何地方使用静态方法获取用户信息。一个典型的获取当前登录用户的姓名的<br>例子如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">  Object principal = SecurityContextHolder.getContext().getAuthentication().getPrincipal();</span><br><span class="line">  if (principal instanceof UserDetails) &#123;</span><br><span class="line">    String username = ((UserDetails)principal).getUsername();</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    String username = principal.toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h5><p>getAuthentication()返回了认证信息，再次getPrincipal()返回了身份信息，UserDetails便是Spring对身份信息封装的一个接口。</p><h4 id="2-Authentication"><a href="#2-Authentication" class="headerlink" title="2 Authentication"></a>2 Authentication</h4><p>&emsp;&emsp;先看看这个接口的源码长什么样：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">package org.springframework.security.core;// &lt;1&gt;</span><br><span class="line">public interface Authentication extends Principal, Serializable &#123; // &lt;1&gt;</span><br><span class="line">    Collection&lt;? extends GrantedAuthority&gt; getAuthorities(); // &lt;2&gt;</span><br><span class="line">    Object getCredentials();// &lt;2&gt;</span><br><span class="line">    Object getDetails();// &lt;2&gt;</span><br><span class="line">    Object getPrincipal();// &lt;2&gt;</span><br><span class="line">    boolean isAuthenticated();// &lt;2&gt;</span><br><span class="line">    void setAuthenticated(boolean var1) throws IllegalArgumentException;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>Authentication是spring security包中的接口，直接继承自Principal类，而Principal是位于java.security包中的。可以见得，Authentication在spring security中是最高级别的身份/认证的抽象。</li><li><p>由这个顶级接口，我们可以得到用户拥有的权限信息列表，密码，用户细节信息，用户身份信息，认证信息。还记得1.1节中，authentication.getPrincipal()返回了一个Object，我们将Principal强转成了Spring Security中最常用的UserDetails，这在Spring Security中非常常见，接口返回Object，使用instanceof判断类型，强转成对应的具体实现类。接口详细解读如下：</p><ul><li>getAuthorities()，权限信息列表，默认是GrantedAuthority接口的一些实现类，通常是代表权限信息的一系列字符串。</li><li>getCredentials()，密码信息，用户输入的密码字符串，在认证过后通常会被移除，用于保障安全。</li><li>getDetails()，细节信息，web应用中的实现接口通常为 WebAuthenticationDetails，它记录了访问者的ip地址和sessionId的值。</li><li>getPrincipal()，敲黑板！！！最重要的身份信息，大部分情况下返回的是UserDetails接口的实现类，也是框架中的常用接口之一。UserDetails接口将会在下面的小节重点介绍。</li></ul></li></ol><h3 id="Spring-Security-身份验证"><a href="#Spring-Security-身份验证" class="headerlink" title="Spring Security 身份验证"></a>Spring Security 身份验证</h3><h4 id="认证过程"><a href="#认证过程" class="headerlink" title="认证过程"></a>认证过程</h4><ol><li><p>用户名和密码被过滤器获取到，封装成 Authentication,通常情况下是 UsernamePasswordAuthenticationToken 这个实现类。</p></li><li><p>AuthenticationManager 身份管理器负责验证这个 Authentication</p></li><li><p>认证成功后，AuthenticationManager身份管理器返回一个被填充满了信息的（包括上面提到的权限信息，身份信息，细节信息，但密码通常会被移除）Authentication实例。</p></li><li><p>SecurityContextHolder安全上下文容器将第3步填充了信息的Authentication，通过SecurityContextHolder.getContext().setAuthentication(…)方法，设置到其中。</p></li></ol><h5 id="说明-1"><a href="#说明-1" class="headerlink" title="说明"></a>说明</h5><p> 这是一个抽象的认证流程，而整个过程中，如果不纠结于细节，其实只剩下一个AuthenticationManager 是我们没有接触过的了，这个身份管理器我们在后面的小节介绍。将上述的流程转换成代码，便是如下的流程：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">public class AuthenticationExample &#123;</span><br><span class="line">private static AuthenticationManager am = new SampleAuthenticationManager();</span><br><span class="line">public static void main(String[] args) throws Exception &#123;</span><br><span class="line">    BufferedReader in = new BufferedReader(new InputStreamReader(System.in));</span><br><span class="line">    while(true) &#123;</span><br><span class="line">    System.out.println(&quot;Please enter your username:&quot;);</span><br><span class="line">    String name = in.readLine();</span><br><span class="line">    System.out.println(&quot;Please enter your password:&quot;);</span><br><span class="line">    String password = in.readLine();</span><br><span class="line">    try &#123;</span><br><span class="line">        Authentication request = new UsernamePasswordAuthenticationToken(name, password);</span><br><span class="line">        Authentication result = am.authenticate(request);</span><br><span class="line">        SecurityContextHolder.getContext().setAuthentication(result);</span><br><span class="line">        break;</span><br><span class="line">    &#125; catch(AuthenticationException e) &#123;</span><br><span class="line">        System.out.println(&quot;Authentication failed: &quot; + e.getMessage());</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(&quot;Successfully authenticated.Security context contains:&quot; +</span><br><span class="line">            SecurityContextHolder.getContext().getAuthentication());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">class SampleAuthenticationManager implements AuthenticationManager &#123;</span><br><span class="line">  static final List&lt;GrantedAuthority&gt; AUTHORITIES = new ArrayList&lt;GrantedAuthority&gt;();</span><br><span class="line">  static &#123;</span><br><span class="line">      AUTHORITIES.add(new SimpleGrantedAuthority(&quot;ROLE_USER&quot;));</span><br><span class="line">  &#125;</span><br><span class="line">  public Authentication authenticate(Authentication auth) throws AuthenticationException &#123;</span><br><span class="line">      if (auth.getName().equals(auth.getCredentials())) &#123;</span><br><span class="line">      return new UsernamePasswordAuthenticationToken(auth.getName(),</span><br><span class="line">          auth.getCredentials(), AUTHORITIES);</span><br><span class="line">      &#125;</span><br><span class="line">      throw new BadCredentialsException(&quot;Bad Credentials&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="注意："><a href="#注意：" class="headerlink" title="注意："></a>注意：</h5><p>上述这段代码只是为了让大家了解Spring Security的工作流程而写的，不是什么源码。在实际使用中，整个流程会变得更加的复杂，但是基本思想，和上述代码如出一辙。</p><h4 id="3-AuthenticationManager"><a href="#3-AuthenticationManager" class="headerlink" title="3 AuthenticationManager"></a>3 AuthenticationManager</h4><p>&emsp;&emsp;AuthenticationManager（接口）是认证相关的核心接口，也是发起认证的出发点，因为在实际需求中，我们可能会允许用户使用用户名+密码登录，同时允许用户使用邮箱+密码，手机号码+密码登录，甚至，可能允许用户使用指纹登录（还有这样的操作？没想到吧），所以说AuthenticationManager一般不直接认证，AuthenticationManager接口的常用实现类ProviderManager 内部会维护一个List<authenticationprovider>列表，存放多种认证方式，实际上这是委托者模式的应用（Delegate）。也就是说，核心的认证入口始终只有一个：AuthenticationManager，不同的认证方式：用户名+密码（UsernamePasswordAuthenticationToken），邮箱+密码，手机号码+密码登录则对应了三个AuthenticationProvider。这样一来是不是就好理解多了？熟悉shiro的朋友可以把AuthenticationProvider理解成Realm。在默认策略下，只需要通过一个AuthenticationProvider的认证，即可被认为是登录成功。</authenticationprovider></p><blockquote><p>AuthenticationManager 内部维护多个AuthenticationProvider，由AuthenticationProvider提供验证信息.</p></blockquote><blockquote><p>统一由AuthenticationManager管理 By author</p></blockquote><blockquote><p>只保留了关键认证部分的ProviderManager源码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">public class ProviderManager implements AuthenticationManager, MessageSourceAware,</span><br><span class="line">        InitializingBean &#123;</span><br><span class="line">    // 维护一个AuthenticationProvider列表</span><br><span class="line">    private List&lt;AuthenticationProvider&gt; providers = Collections.emptyList();</span><br><span class="line"></span><br><span class="line">    public Authentication authenticate(Authentication authentication)</span><br><span class="line">          throws AuthenticationException &#123;</span><br><span class="line">       Class&lt;? extends Authentication&gt; toTest = authentication.getClass();</span><br><span class="line">       AuthenticationException lastException = null;</span><br><span class="line">       Authentication result = null;</span><br><span class="line">       // 依次认证</span><br><span class="line">       for (AuthenticationProvider provider : getProviders()) &#123;</span><br><span class="line">          if (!provider.supports(toTest)) &#123;</span><br><span class="line">             continue;</span><br><span class="line">          &#125;</span><br><span class="line">          try &#123;</span><br><span class="line">             result = provider.authenticate(authentication);</span><br><span class="line">             if (result != null) &#123;</span><br><span class="line">                copyDetails(authentication, result);</span><br><span class="line">                break;</span><br><span class="line">             &#125;</span><br><span class="line">          &#125;</span><br><span class="line">          ...</span><br><span class="line">          catch (AuthenticationException e) &#123;</span><br><span class="line">             lastException = e;</span><br><span class="line">          &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       // 如果有Authentication信息，则直接返回</span><br><span class="line">       if (result != null) &#123;</span><br><span class="line">            if (eraseCredentialsAfterAuthentication</span><br><span class="line">                    &amp;&amp; (result instanceof CredentialsContainer)) &#123;</span><br><span class="line">                 //移除密码</span><br><span class="line">                ((CredentialsContainer) result).eraseCredentials();</span><br><span class="line">            &#125;</span><br><span class="line">             //发布登录成功事件</span><br><span class="line">            eventPublisher.publishAuthenticationSuccess(result);</span><br><span class="line">            return result;</span><br><span class="line">       &#125;</span><br><span class="line">       ...</span><br><span class="line">       //执行到此，说明没有认证成功，包装异常信息</span><br><span class="line">       if (lastException == null) &#123;</span><br><span class="line">          lastException = new ProviderNotFoundException(messages.getMessage(</span><br><span class="line">                &quot;ProviderManager.providerNotFound&quot;,</span><br><span class="line">                new Object[] &#123; toTest.getName() &#125;,</span><br><span class="line">                &quot;No AuthenticationProvider found for &#123;0&#125;&quot;));</span><br><span class="line">       &#125;</span><br><span class="line">       prepareException(lastException, authentication);</span><br><span class="line">       throw lastException;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></blockquote><p>&emsp;&emsp; ProviderManager 中的List，会依照次序去认证，认证成功则立即返回，若认证失败则返回null，下一个AuthenticationProvider会继续尝试认证，如果所有认证器都无法认证成功，则ProviderManager 会抛出一个ProviderNotFoundException异常。<br>到这里，如果不纠结于AuthenticationProvider的实现细节以及安全相关的过滤器，认证相关的核心类其实都已经介绍完毕了：身份信息的存放容器SecurityContextHolder，身份信息的抽象Authentication，身份认证器AuthenticationManager及其认证流程。姑且在这里做一个分隔线。下面来介绍下AuthenticationProvider接口的具体实现。</p><h5 id="3-1-DaoAuthenticationProvider"><a href="#3-1-DaoAuthenticationProvider" class="headerlink" title="3.1 DaoAuthenticationProvider"></a>3.1 DaoAuthenticationProvider</h5><p>&emsp;&emsp;AuthenticationProvider最常用的一个实现便是DaoAuthenticationProvider。顾名思义，Dao正是数据访问层的缩写，也暗示了这个身份认证器的实现思路。由于本文是一个Overview，姑且只给出其UML类图</p><p><img src="http://p4ucv3uvl.bkt.clouddn.com/blog/DaoAuthenticationProvider.png" alt="UML图"></p><p>&emsp;&emsp;按照我们最直观的思路，怎么去认证一个用户呢？用户前台提交了用户名和密码，而数据库中保存了用户名和密码，认证便是负责比对同一个用户名，提交的密码和保存的密码是否相同便是了。在Spring Security中。提交的用户名和密码，被封装了UsernamePasswordAuthenticationToken，而根据用户名加载用户的任务则是交给了UserDetailsService，在DaoAuthenticationProvider中，对应的方法便是retrieveUser，虽然有两个参数，但是retrieveUser只有第一个参数起主要作用，返回一个UserDetails。还需要完成UsernamePasswordAuthenticationToken和UserDetails密码的比对，这便是交给additionalAuthenticationChecks方法完成的，如果这个void方法没有抛异常，则认为比对成功。比对密码的过程，用到了PasswordEncoder和SaltSource，密码加密和盐的概念相信不用我赘述了，它们为保障安全而设计，都是比较基础的概念。</p><p>&emsp;&emsp;如果你已经被这些概念搞得晕头转向了，不妨这么理解DaoAuthenticationProvider：它获取用户提交的用户名和密码，比对其正确性，如果正确，返回一个数据库中的用户信息（假设用户信息被保存在数据库中）。</p><h5 id="3-2-UserDetails与UserDetailsService"><a href="#3-2-UserDetails与UserDetailsService" class="headerlink" title="3.2 UserDetails与UserDetailsService"></a>3.2 UserDetails与UserDetailsService</h5><p>&emsp;&emms;上面不断提到了UserDetails这个接口，它代表了最详细的用户信息，这个接口涵盖了一些必要的用户信息字段，具体的实现类对它进行了扩展。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public interface UserDetails extends Serializable &#123;</span><br><span class="line">   Collection&lt;? extends GrantedAuthority&gt; getAuthorities();</span><br><span class="line">   String getPassword();</span><br><span class="line">   String getUsername();</span><br><span class="line">   boolean isAccountNonExpired();</span><br><span class="line">   boolean isAccountNonLocked();</span><br><span class="line">   boolean isCredentialsNonExpired();</span><br><span class="line">   boolean isEnabled();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emms;它和Authentication接口很类似，比如它们都拥有username，authorities，区分他们也是本文的重点内容之一。Authentication的getCredentials()与UserDetails中的getPassword()需要被区分对待，前者是用户提交的密码凭证，后者是用户正确的密码，认证器其实就是对这两者的比对。Authentication中的getAuthorities()实际是由UserDetails的getAuthorities()传递而形成的。还记得Authentication接口中的getUserDetails()方法吗？其中的UserDetails用户详细信息便是经过了AuthenticationProvider之后被填充的.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public interface UserDetailsService &#123;</span><br><span class="line">   UserDetails loadUserByUsername(String username) throws UsernameNotFoundException;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;UserDetailsService和AuthenticationProvider两者的职责常常被人们搞混，关于他们的问题在文档的FAQ和issues中屡见不鲜。记住一点即可，敲黑板！！！UserDetailsService只负责从特定的地方（通常是数据库）加载用户信息，仅此而已，记住这一点，可以避免走很多弯路。UserDetailsService常见的实现类有JdbcDaoImpl，InMemoryUserDetailsManager，前者从数据库加载用户，后者从内存中加载用户，也可以自己实现UserDetailsService，通常这更加灵活。</p><h4 id="4-整体架构图"><a href="#4-整体架构图" class="headerlink" title="4 整体架构图"></a>4 整体架构图</h4><p><img src="http://p4ucv3uvl.bkt.clouddn.com/blog/blog/structure.png" alt=""></p><h2 id="二-代码篇"><a href="#二-代码篇" class="headerlink" title="二 代码篇"></a>二 代码篇</h2><p><a href="https://github.com/spring-projects/spring-security/tree/master/samples/boot/helloworld" target="_blank" rel="noopener">入门例子</a></p><h3 id="核心配置"><a href="#核心配置" class="headerlink" title="核心配置"></a>核心配置</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">@EnableWebSecurity</span><br><span class="line">public class WebSecurityConfig extends WebSecurityConfigurerAdapter &#123;</span><br><span class="line">  @Override</span><br><span class="line">  protected void configure(HttpSecurity http) throws Exception &#123;</span><br><span class="line">      http</span><br><span class="line">          .authorizeRequests()</span><br><span class="line">              .antMatchers(&quot;/&quot;, &quot;/home&quot;).permitAll()</span><br><span class="line">              .anyRequest().authenticated()</span><br><span class="line">              .and()</span><br><span class="line">          .formLogin()</span><br><span class="line">              .loginPage(&quot;/login&quot;)</span><br><span class="line">              .permitAll()</span><br><span class="line">              .and()</span><br><span class="line">          .logout()</span><br><span class="line">              .permitAll();</span><br><span class="line">  &#125;</span><br><span class="line">  @Autowired</span><br><span class="line">  public void configureGlobal(AuthenticationManagerBuilder auth) throws Exception &#123;</span><br><span class="line">    // 内存中配置admin用户，密码admin，角色USER</span><br><span class="line">      auth</span><br><span class="line">          .inMemoryAuthentication()</span><br><span class="line">              .withUser(&quot;admin&quot;).password(&quot;admin&quot;).roles(&quot;USER&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="说明-2"><a href="#说明-2" class="headerlink" title="说明"></a>说明</h5><p>&emsp;&emsp;当配置了上述的javaconfig之后，我们的应用便具备了如下的功能：</p><ul><li>除了“/”,”/home”(首页),”/login”(登录),”/logout”(注销),之外，其他路径都需要认证。</li><li>指定“/login”该路径为登录页面，当未认证的用户尝试访问任何受保护的资源时，都会跳转到“/login”。</li><li>默认指定“/logout”为注销页面</li><li>配置一个内存中的用户认证器，使用admin/admin作为用户名和密码，具有USER角色</li><li>防止CSRF攻击</li><li>Session Fixation protection(可以参考我之前讲解Spring Session的文章，防止别人篡改sessionId)</li><li>Security Header(添加一系列和Header相关的控制)</li><li>HTTP Strict Transport Security for secure requests</li><li>集成X-Content-Type-Options</li><li>缓存控制</li><li>集成X-XSS-Protection.aspx)</li><li>X-Frame-Options integration to help prevent Clickjacking(iframe被默认禁止使用)</li><li>为Servlet API集成了如下的几个方法</li><li>HttpServletRequest#getRemoteUser())</li><li>HttpServletRequest.html#getUserPrincipal())</li><li>HttpServletRequest.html#isUserInRole(java.lang.String))</li><li>HttpServletRequest.html#login(java.lang.String, java.lang.String))</li><li>HttpServletRequest.html#logout())</li></ul><h4 id="注解-EnableWebSecurity"><a href="#注解-EnableWebSecurity" class="headerlink" title="注解 @EnableWebSecurity"></a>注解 @EnableWebSecurity</h4><p>我们自己定义的配置类WebSecurityConfig加上了@EnableWebSecurity注解，同时继承了WebSecurityConfigurerAdapter。你可能会在想谁的作用大一点，毫无疑问@EnableWebSecurity起到决定性的配置作用，它其实是个组合注解。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@Import(&#123; WebSecurityConfiguration.class, // &lt;2&gt;</span><br><span class="line">      SpringWebMvcImportSelector.class &#125;) // &lt;1&gt;</span><br><span class="line">@EnableGlobalAuthentication // &lt;3&gt;</span><br><span class="line">@Configuration</span><br><span class="line">public @interface EnableWebSecurity &#123;</span><br><span class="line">   boolean debug() default false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>@Import是springboot提供的用于引入外部的配置的注解，可以理解为：@EnableWebSecurity注解激活了@Import注解中包含的配置类。</p></li><li><p>SpringWebMvcImportSelector的作用是判断当前的环境是否包含springmvc，因为spring security可以在非spring环境下使用，为了避免DispatcherServlet的重复配置，所以使用了这个注解来区分。</p></li><li><p>WebSecurityConfiguration顾名思义，是用来配置web安全的，下面的小节会详细介绍。</p></li><li><p>@EnableGlobalAuthentication注解的源码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@Import(AuthenticationConfiguration.class)</span><br><span class="line">@Configuration</span><br><span class="line">public @interface EnableGlobalAuthentication &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>注意点同样在@Import之中，它实际上激活了AuthenticationConfiguration这样的一个配置类，用来配置认证相关的核心类。也就是说，@EnableWebSecurity完成的工作便是加载了WebSecurityConfiguration，AuthenticationConfiguration这两个核心配置类，也就此将spring security的职责划分为了配置安全信息，配置认证信息两部分。</p><h4 id="WebSecurityConfiguration"><a href="#WebSecurityConfiguration" class="headerlink" title="WebSecurityConfiguration"></a>WebSecurityConfiguration</h4><p>在这个配置类中，有一个非常重要的Bean被注册了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">public class WebSecurityConfiguration &#123;</span><br><span class="line">//DEFAULT_FILTER_NAME = &quot;springSecurityFilterChain&quot;</span><br><span class="line">@Bean(name = AbstractSecurityWebApplicationInitializer.DEFAULT_FILTER_NAME)</span><br><span class="line">    public Filter springSecurityFilterChain() throws Exception &#123;</span><br><span class="line">    ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>在未使用springboot之前，大多数人都应该对“springSecurityFilterChain”这个名词不会陌生，他是spring security的核心过滤器，是整个认证的入口。在曾经的XML配置中，想要启用spring security，需要在web.xml中进行如下配置：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- Spring Security --&gt;</span><br><span class="line">   &lt;filter&gt;</span><br><span class="line">       &lt;filter-name&gt;springSecurityFilterChain&lt;/filter-name&gt;</span><br><span class="line">       &lt;filter-class&gt;org.springframework.web.filter.DelegatingFilterProxy&lt;/filter-class&gt;</span><br><span class="line">   &lt;/filter&gt;</span><br><span class="line">   &lt;filter-mapping&gt;</span><br><span class="line">       &lt;filter-name&gt;springSecurityFilterChain&lt;/filter-name&gt;</span><br><span class="line">       &lt;url-pattern&gt;/*&lt;/url-pattern&gt;</span><br><span class="line">   &lt;/filter-mapping&gt;</span><br></pre></td></tr></table></figure><h4 id="AuthenticationConfiguration"><a href="#AuthenticationConfiguration" class="headerlink" title="AuthenticationConfiguration"></a>AuthenticationConfiguration</h4><p>而在springboot集成之后，这样的XML被java配置取代。WebSecurityConfiguration中完成了声明springSecurityFilterChain的作用，并且最终交给DelegatingFilterProxy这个代理类，负责拦截请求（注意DelegatingFilterProxy这个类不是spring security包中的，而是存在于web包中，spring使用了代理模式来实现安全过滤的解耦）。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">@Import(ObjectPostProcessorConfiguration.class)</span><br><span class="line">public class AuthenticationConfiguration &#123;</span><br><span class="line">  @Bean</span><br><span class="line">public AuthenticationManagerBuilder authenticationManagerBuilder(</span><br><span class="line">ObjectPostProcessor&lt;Object&gt; objectPostProcessor) &#123;</span><br><span class="line">return new AuthenticationManagerBuilder(objectPostProcessor);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">  public AuthenticationManager getAuthenticationManager() throws Exception &#123;</span><br><span class="line">    ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>AuthenticationConfiguration的主要任务，便是负责生成全局的身份认证管理者AuthenticationManager。还记得在《Spring Security(一) 基础篇》中，介绍了Spring Security的认证体系，AuthenticationManager便是最核心的身份认证管理器。</p><h4 id="WebSecurityConfigurerAdapter"><a href="#WebSecurityConfigurerAdapter" class="headerlink" title="WebSecurityConfigurerAdapter"></a>WebSecurityConfigurerAdapter</h4><p><img src="http://p4ucv3uvl.bkt.clouddn.com/blog/WebSecurityConfigurerAdapter.png" alt="WebSecurityConfigurerAdapter"></p><p>由参数就可以知道，分别是对AuthenticationManagerBuilder，WebSecurity，HttpSecurity进行个性化的配置。</p><h5 id="HttpSecurity常用配置"><a href="#HttpSecurity常用配置" class="headerlink" title="HttpSecurity常用配置"></a>HttpSecurity常用配置</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">@EnableWebSecurity</span><br><span class="line">public class CustomWebSecurityConfig extends WebSecurityConfigurerAdapter &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected void configure(HttpSecurity http) throws Exception &#123;</span><br><span class="line">        http</span><br><span class="line">            .authorizeRequests()</span><br><span class="line">                .antMatchers(&quot;/resources/**&quot;, &quot;/signup&quot;, &quot;/about&quot;).permitAll()</span><br><span class="line">                .antMatchers(&quot;/admin/**&quot;).hasRole(&quot;ADMIN&quot;)</span><br><span class="line">                .antMatchers(&quot;/db/**&quot;).access(&quot;hasRole(&apos;ADMIN&apos;) and hasRole(&apos;DBA&apos;)&quot;)</span><br><span class="line">                .anyRequest().authenticated()</span><br><span class="line">                .and()</span><br><span class="line">            .formLogin()</span><br><span class="line">                .usernameParameter(&quot;username&quot;)</span><br><span class="line">                .passwordParameter(&quot;password&quot;)</span><br><span class="line">                .failureForwardUrl(&quot;/login?error&quot;)</span><br><span class="line">                .loginPage(&quot;/login&quot;)</span><br><span class="line">                .permitAll()</span><br><span class="line">                .and()</span><br><span class="line">            .logout()</span><br><span class="line">                .logoutUrl(&quot;/logout&quot;)</span><br><span class="line">                .logoutSuccessUrl(&quot;/index&quot;)</span><br><span class="line">                .permitAll()</span><br><span class="line">                .and()</span><br><span class="line">            .httpBasic()</span><br><span class="line">                .disable();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述是一个使用Java Configuration配置HttpSecurity的典型配置，其中http作为根开始配置，每一个and()对应了一个模块的配置（等同于xml配置中的结束标签），并且and()返回了HttpSecurity本身，于是可以连续进行配置。他们配置的含义也非常容易通过变量本身来推测，</p><ul><li>authorizeRequests()配置路径拦截，表明路径访问所对应的权限，角色，认证信息。</li><li>formLogin()对应表单认证相关的配置</li><li>logout()对应了注销相关的配置</li><li>httpBasic()可以配置basic登录</li><li>etc</li></ul><p>他们分别代表了http请求相关的安全配置，这些配置项无一例外的返回了Configurer类，而所有的http相关配置可以通过查看 HttpSecurity 的主要方法得知：</p><p><img src="http://p4ucv3uvl.bkt.clouddn.com/blog/HttpSecurity.png" alt="HttpSecurity"></p><p>需要对http协议有一定的了解才能完全掌握所有的配置，不过，springboot和spring security的自动配置已经足够使用了。其中每一项Configurer（e.g.FormLoginConfigurer,CsrfConfigurer）都是HttpConfigurer的细化配置项。</p><h4 id="WebSecurityBuilder"><a href="#WebSecurityBuilder" class="headerlink" title="WebSecurityBuilder"></a>WebSecurityBuilder</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">@EnableWebSecurity</span><br><span class="line">public class WebSecurityConfig extends WebSecurityConfigurerAdapter &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void configure(WebSecurity web) throws Exception &#123;</span><br><span class="line">        web</span><br><span class="line">            .ignoring()</span><br><span class="line">            .antMatchers(&quot;/resources/**&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="AuthenticationManagerBuilder"><a href="#AuthenticationManagerBuilder" class="headerlink" title="AuthenticationManagerBuilder"></a>AuthenticationManagerBuilder</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">@EnableWebSecurity</span><br><span class="line">public class WebSecurityConfig extends WebSecurityConfigurerAdapter &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected void configure(AuthenticationManagerBuilder auth) throws Exception &#123;</span><br><span class="line">        auth</span><br><span class="line">            .inMemoryAuthentication()</span><br><span class="line">            .withUser(&quot;admin&quot;).password(&quot;admin&quot;).roles(&quot;USER&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>想要在 WebSecurityConfigurerAdapter 中进行认证相关的配置，可以使用 configure(AuthenticationManagerBuilder auth) 暴露一个 AuthenticationManager 的建造器：AuthenticationManagerBuilder 。如上所示，我们便完成了内存中用户的配置。</p><blockquote><p>有待考证 TODO</p></blockquote><p>如果你的应用只有唯一一个WebSecurityConfigurerAdapter，那么他们之间的差距可以被忽略，从方法名可以看出两者的区别：使用@Autowired注入的AuthenticationManagerBuilder是全局的身份认证器，作用域可以跨越多个WebSecurityConfigurerAdapter，以及影响到基于Method的安全控制；而 protected configure()的方式则类似于一个匿名内部类，它的作用域局限于一个WebSecurityConfigurerAdapter内部。关于这一点的区别，可以参考我曾经提出的issuespring-security#issues4571。官方文档中，也给出了配置多个WebSecurityConfigurerAdapter的场景以及demo，将在该系列的后续文章中解读</p><h2 id="三-高级篇"><a href="#三-高级篇" class="headerlink" title="三 高级篇"></a>三 高级篇</h2><hr><h3 id="原理-1"><a href="#原理-1" class="headerlink" title="原理"></a>原理</h3><h4 id="Servlet"><a href="#Servlet" class="headerlink" title="Servlet"></a>Servlet</h4><p>&emsp;&emsp;Servlet过滤器被用来拦截用户请求来进行请求之前或之后的处理，或者干脆重定向这个请求，这取决于servlet过滤器的功能。</p><p>Servlet过滤器处理之后的目标servlet是 MVC 分发web servlet。</p><p>servlet请求按照一定的顺序从一个过滤器到下一个穿过整个过滤器链，最终到达目标servlet。与之相对的是，当servelt处理完请求并返回一个response时，过滤器链按照相反的顺序再线性次穿过所有的过滤器。</p><h4 id="Spring-Security"><a href="#Spring-Security" class="headerlink" title="Spring Security"></a>Spring Security</h4><p>&emsp;&emsp;Spring Security利用Spring在XML配置文件中的自动配置属性，建立了十个servlet过滤器，这些过滤器并没有配置在web.xml中，而是由Spring Factory使用JavaEE的servlet过滤器链将他们按顺序组装。</p><p>Spring Security使用了过滤器链的实现了自己的抽象，提供了VirtualFilterChain，它可以根据Spring Security XML配置文件中设置的URL模式动态的创建过滤器链（可以将它与标准的Java EE过滤器链进行对比，后者需要在web应用的部署描述文件中进行设置）。</p><p>&emsp;&emsp;Spring Security的自动配置选项auto-config为你建立了十个Spring Security的过滤器。这些过滤器以及它们使用的顺序，在下面的表格中进行了描述。</p><p>如：UsernamePasswordAuthenticationFilter是通过<http>配置指令的<form-login>子元素来进行配置的。</form-login></http></p><table><thead><tr><th style="text-align:left">过滤器名称</th><th style="text-align:center">描述</th><th style="text-align:right">说明</th></tr></thead><tbody><tr><td style="text-align:left">SecurityContextPersistenceFilter</td><td style="text-align:center">负责从SecurityContextRepository获取或存储SecurityContext。SecurityContext代表了用户安全和认证过的session。</td><td style="text-align:right"></td></tr><tr><td style="text-align:left">LogoutFilter</td><td style="text-align:center">监控一个实际为退出功能的URL（默认为/j_spring_security_logout），并且在匹配的时候完成用户的退出功能。</td><td style="text-align:right"></td></tr><tr><td style="text-align:left">UsernamePasswordAuthenticationFilter</td><td style="text-align:center">监控一个使用用户名和密码基于form认证的URL（默认为/j_spring_security_check），并在URL匹配的情况下尝试认证该用户。</td><td style="text-align:right"></td></tr><tr><td style="text-align:left">DefaultLoginPageGeneratingFilter</td><td style="text-align:center">监控一个要进行基于forn或OpenID认证的URL（默认为/spring_security_login），并生成展现登录form的HTML</td><td style="text-align:right"></td></tr><tr><td style="text-align:left">BasicAuthenticationFilter</td><td style="text-align:center">监控HTTP 基础认证的头信息并进行处理</td><td style="text-align:right"></td></tr><tr><td style="text-align:left">RequestCacheAwareFilter</td><td style="text-align:center">用于用户登录成功后，重新恢复因为登录被打断的请求。</td><td style="text-align:right"></td></tr><tr><td style="text-align:left">SecurityContextHolderAwareRequestFilter</td><td style="text-align:center">用一个扩展了HttpServletRequestWrapper的子类（o.s.s.web.servletapi.SecurityContextHolderAwareRequestWrapper）包装HttpServletRequest。它为请求处理器提供了额外的上下文信息。</td><td style="text-align:right"></td></tr><tr><td style="text-align:left">AnonymousAuthenticationFilter</td><td style="text-align:center">如果用户到这一步还没有经过认证，将会为这个请求关联一个认证的token，标识此用户是匿名的。</td><td style="text-align:right"></td></tr><tr><td style="text-align:left">SessionManagementFilter</td><td style="text-align:center">根据认证的安全实体信息跟踪session，保证所有关联一个安全实体的session都能被跟踪到。</td><td style="text-align:right"></td></tr><tr><td style="text-align:left">ExceptionTranslationFilter</td><td style="text-align:center">解决在处理一个请求时产生的指定异常</td><td style="text-align:right"></td></tr><tr><td style="text-align:left">FilterSecurityInterceptor</td><td style="text-align:center">简化授权和访问控制决定，委托一个AccessDecisionManager完成授权的判断</td></tr></tbody></table><p>重要的过滤器<br>|过滤器名称|描述|说明|<br>|-|-|-|<br>|AbstractAuthenticationProcessingFilter|认证进程过滤器||<br>||||</p><h2 id="四-使用-Spring-Security"><a href="#四-使用-Spring-Security" class="headerlink" title="四 使用 Spring Security"></a>四 使用 Spring Security</h2><h3 id="Spring-Boot-使用-Spring-Security"><a href="#Spring-Boot-使用-Spring-Security" class="headerlink" title="Spring Boot 使用 Spring Security"></a>Spring Boot 使用 Spring Security</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- spring security依赖 --&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">          &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">          &lt;artifactId&gt;spring-boot-starter-security&lt;/artifactId&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br></pre></td></tr></table></figure><h2 id="相关参考网址"><a href="#相关参考网址" class="headerlink" title="相关参考网址"></a>相关参考网址</h2><p><a href="http://www.importnew.com/26712.html" target="_blank" rel="noopener">参考</a><br><br><a href="https://springcloud.cc/spring-security-zhcn.html" target="_blank" rel="noopener">官方文档 - 中文翻译</a><br><br><a href="http://www.cnblogs.com/SmallTalker/p/7851848.html" target="_blank" rel="noopener">Spring boot中Spring Security 使用5部曲</a><br><br><a href="http://www.360doc.com/content/10/0422/11/15643_24320208.shtml" target="_blank" rel="noopener">Spring Security 11种过滤器介绍</a><br><br><a href="https://www.cnblogs.com/lexiaofei/p/7059966.html" target="_blank" rel="noopener">Spring Security过滤器机制</a><br><br><a href="https://www.hellojava.com/article/815" target="_blank" rel="noopener">参考</a><br>[Spring Security(四)–核心过滤器源码分析]（<a href="http://blog.didispace.com/xjf-spring-security-4/）" target="_blank" rel="noopener">http://blog.didispace.com/xjf-spring-security-4/）</a><br><a href="http://www.cnblogs.com/final-elysion/p/6074572.html" target="_blank" rel="noopener">spring mvc参考</a><br><a href="https://www.cnblogs.com/linhp/p/5817054.html" target="_blank" rel="noopener">FilterInvocationSecurityMetadataSource</a><br><a href="http://www.cnblogs.com/fenglan/category/887982.html" target="_blank" rel="noopener">spring security</a><br><a href="http://www.baeldung.com/spring-security-custom-configurer" target="_blank" rel="noopener">Custom Configurer</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Welcome to Wuwei`Blog&lt;/p&gt;
&lt;h1 id=&quot;Spring-Security-based-on-Spring-Boot&quot;&gt;&lt;a href=&quot;#Spring-Security-based-on-Spring-Boot&quot; class=&quot;headerlink
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Spring Boot 远程调试</title>
    <link href="http://yoursite.com/2018/03/14/springboot-debug/"/>
    <id>http://yoursite.com/2018/03/14/springboot-debug/</id>
    <published>2018-03-14T15:28:18.325Z</published>
    <updated>2018-03-14T15:31:17.833Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to Wuwei`Blog</p><h1 id="Spring-Boot-调试"><a href="#Spring-Boot-调试" class="headerlink" title="Spring Boot 调试"></a>Spring Boot 调试</h1><h2 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h2><h3 id="Spring-Boot-工程"><a href="#Spring-Boot-工程" class="headerlink" title="Spring Boot 工程"></a>Spring Boot 工程</h3><h3 id="idea开发环境"><a href="#idea开发环境" class="headerlink" title="idea开发环境"></a>idea开发环境</h3><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>&emsp;&emsp;本篇博客介绍一下在Intellij IDEA下对Springboot类型的项目的远程调试功能。所谓的远程调试就是服务端程序运行在一台远程服务器上，我们可以在本地服务端的代码（前提是本地的代码必须和远程服务器运行的代码一致）中设置断点，每当有请求到远程服务器时时能够在本地知道远程服务端的此时的内部状态.</p><h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><p>&emsp;&emsp;首先，打开Edit configurations，点击+号，创建一个Remote应用。<br><img src="http://p4ucv3uvl.bkt.clouddn.com/blog/CreateRemote.png" alt="Create Remote"></p><p>&emsp;&emsp;填写name，配置Host地址（远程服务器地址）和端口（选一个未被占用的端口）。然后复制For JDK1.4.x下面的参数，示例配置的端口为5005：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-Xdebug -Xrunjdwp:transport=dt_socket,server=y,suspend=n,address=5005</span><br></pre></td></tr></table></figure></p><p><img src="http://p4ucv3uvl.bkt.clouddn.com/blog/ConfigRemote.png" alt="Config Remote"></p><p>&emsp;&emsp;经过以上步骤，已经获得了启动远程服务器的参数。在启动springboot时默认使用java命令来启动。<br>比如，示例项目启动命令为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -jar test-tool.jar</span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;那么此时在启动命令上添加上面获得的参数：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -jar -Xdebug -Xrunjdwp:transport=dt_socket,server=y,suspend=n,address=5005 test-tool.jar</span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;这样服务端就监听在5005端口了。可以通过以下命令来检查是否监听成功：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">netstat -anp | grep 5005</span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;通过以上步骤已经完成了服务器端参数的添加。下面启动刚才配置的Remote服务，即test-tool-remote。在启动时候我们会发现此项启动程序只有debug启动模式。<br>&emsp;&emsp;启动完成，对需要debug的代码打上断点，剩下的操作步骤就是访问远程服务器对应的业务请求，本地就会同步debug。其余的操作与本地debug相同，此处就不再赘述了。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Welcome to Wuwei`Blog&lt;/p&gt;
&lt;h1 id=&quot;Spring-Boot-调试&quot;&gt;&lt;a href=&quot;#Spring-Boot-调试&quot; class=&quot;headerlink&quot; title=&quot;Spring Boot 调试&quot;&gt;&lt;/a&gt;Spring Boot 调试&lt;
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Git</title>
    <link href="http://yoursite.com/2018/03/14/git/"/>
    <id>http://yoursite.com/2018/03/14/git/</id>
    <published>2018-03-14T15:26:12.745Z</published>
    <updated>2018-03-14T15:31:17.826Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Git"><a href="#Git" class="headerlink" title="Git"></a>Git</h1><h2 id="分支"><a href="#分支" class="headerlink" title="分支"></a>分支</h2><h3 id="删除远程分支并保留本地分支"><a href="#删除远程分支并保留本地分支" class="headerlink" title="删除远程分支并保留本地分支"></a>删除远程分支并保留本地分支</h3><p>&emsp;&emsp;先声明一点，如果要同时删除本地的和github上的文件，直接删除本地的再push就行了，比较简单。这里的要求是不能删除本地的文件，而要删除github里，就是网页上的文件。<br>&emsp;&emsp;其实质就是删除缓冲区里的文件，再提交给服务器端。</p><ol><li><p>首先进入要删除的文件夹或文件的根目录下，如F:\myprojects\supermarketmanager1115</p></li><li><p>执行下面的语句”some-directory”是相对于本地根目录下的文件夹/文件路径</p></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git rm -r --cached some-directory</span><br><span class="line">git commit -m &apos;Remove the now ignored directory &quot;some-directory&quot;&apos;</span><br><span class="line">git push origin master</span><br></pre></td></tr></table></figure><p>另外git pull –rebase origin master，记录一下。这句的意思是：把github上最新的文件下载下来。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Git&quot;&gt;&lt;a href=&quot;#Git&quot; class=&quot;headerlink&quot; title=&quot;Git&quot;&gt;&lt;/a&gt;Git&lt;/h1&gt;&lt;h2 id=&quot;分支&quot;&gt;&lt;a href=&quot;#分支&quot; class=&quot;headerlink&quot; title=&quot;分支&quot;&gt;&lt;/a&gt;分支&lt;/h2&gt;&lt;h
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Logback 标准xml参考</title>
    <link href="http://yoursite.com/2018/03/14/logback/"/>
    <id>http://yoursite.com/2018/03/14/logback/</id>
    <published>2018-03-14T15:26:09.065Z</published>
    <updated>2018-03-14T15:31:17.830Z</updated>
    
    <content type="html"><![CDATA[<h3 id="强制："><a href="#强制：" class="headerlink" title="强制："></a>强制：</h3><ol><li>【强制】应用中不可直接使用日志系统(Log4j、Logback)中的 API，而应依赖使用日志框架<br>SLF4J 中的 API，使用门面模式的日志框架，有利于维护和各个类的日志处理方式统一。<br>import org.slf4j.Logger;<br>import org.slf4j.LoggerFactory;<br>private static final Logger logger = LoggerFactory.getLogger(Abc.class);</li><li>【强制】日志文件推荐至少保存 15 天，因为有些异常具备以“周”为频次发生的特点。</li><li>【强制】应用中的扩展日志(如打点、临时监控、访问日志等)命名方式: appName_logType_logName.log。logType:日志类型，推荐分类有 stats/monitor/visit 等; logName:日志描述。这种命名的好处:通过文件名就可知道日志文件属于什么应用，什么类 型，什么目的，也有利于归类查找。<br>正例:mppserver 应用中单独监控时区转换异常，如: mppserver_monitor_timeZoneConvert.log 说明:推荐对日志进行分类，如将错误日志和业务日志分开存放，便于开发人员查看，也便于 通过日志对系统进行及时监控。</li><li>【强制】对 trace/debug/info 级别的日志输出，必须使用条件输出形式或者使用占位符的方式。<br>说明:logger.debug(“Processing trade with id: “ + id + “ and symbol: “ + symbol); 如果日志级别是 warn，上述日志不会打印，但是会执行字符串拼接操作，如果 symbol 是对象， 会执行 toString()方法，浪费了系统资源，执行了上述操作，最终日志却没有打印。 正例:(条件)<br>if (logger.isDebugEnabled()) {<br>logger.debug(“Processing trade with id: “ + id + “ and symbol: “ + symbol);<br>}<br>正例:(占位符)<br>logger.debug(“Processing trade with id: {} and symbol : {} “, id, symbol);</li><li>【强制】避免重复打印日志，浪费磁盘空间，务必在 log4j.xml 中设置 additivity=false。<br>正例:<logger name="com.taobao.dubbo.config" additivity="false"></logger></li><li>【强制】异常信息应该包括两类信息:案发现场信息和异常堆栈信息。如果不处理，那么通过 关键字 throws 往上抛出。<br>正例:logger.error(各类参数或者对象toString + “_” + e.getMessage(), e);<h3 id="推荐："><a href="#推荐：" class="headerlink" title="推荐："></a>推荐：</h3></li><li>【推荐】谨慎地记录日志。生产环境禁止输出 debug 日志;有选择地输出 info 日志;如果使 用 warn 来记录刚上线时的业务行为信息，一定要注意日志输出量的问题，避免把服务器磁盘 撑爆，并记得及时删除这些观察日志。 说明:大量地输出无效日志，不利于系统性能提升，也不利于快速定位错误点。记录日志时请 思考:这些日志真的有人看吗?看到这条日志你能做什么?能不能给问题排查带来好处?</li><li>【推荐】可以使用 warn 日志级别来记录用户输入参数错误的情况，避免用户投诉时，无所适从。如非必要，请不要在此场景打出 error 级别，避免频繁报警。 说明:注意日志输出的级别，error 级别只记录系统逻辑出错、异常或者重要的错误信息。</li></ol><h3 id="福利"><a href="#福利" class="headerlink" title="福利"></a>福利</h3><p>spring boot 相关日志配置说明</p><p>spring boot 日志可以借住lombok插件。<br>安装 lombok 的插件，并配置。<br>    Go to File &gt; Settings &gt; Plugins<br>    Click on Browse repositories…<br>    Search for Lombok Plugin<br>    Click on Install plugin<br>    Restart Android Studio<br>    允许注解处理，Settings -&gt; Compiler -&gt; Annotation Processors</p><p>使用时，需要再类上面加注解 @Slf4j 则可以直接使用log变量进行日志处理。</p><p>相关引用地址：<br><a href="http://blog.csdn.net/inke88/article/details/75007649" target="_blank" rel="noopener">http://blog.csdn.net/inke88/article/details/75007649</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;configuration scan=&quot;true&quot; scanPeriod=&quot;60 seconds&quot; debug=&quot;false&quot;&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!--application.yml 传递参数，不能使用logback 自带的&lt;property&gt;标签 --&gt;</span><br><span class="line">    &lt;springProperty scope=&quot;context&quot; name=&quot;appname&quot; source=&quot;logback.appname&quot;/&gt;</span><br><span class="line">    &lt;springProperty scope=&quot;context&quot; name=&quot;logdir&quot; source=&quot;logback.logdir&quot;/&gt;</span><br><span class="line"></span><br><span class="line">    &lt;contextName&gt;$&#123;appname&#125;&lt;/contextName&gt;</span><br><span class="line">    &lt;!--======================================= 本地变量 ======================================== --&gt;</span><br><span class="line">    &lt;!--在没有定义$&#123;LOG_HOME&#125;系统变量的时候，可以设置此本地变量。提交测试、上线时，要将其注释掉，使用系统变量。 --&gt;</span><br><span class="line">    &lt;property name=&quot;LOG_HOME&quot; value=&quot;/Users/wuwei/Documents/Logs&quot; /&gt;</span><br><span class="line">    &lt;!-- 应用名称：和统一配置中的项目代码保持一致（小写） --&gt;</span><br><span class="line">    &lt;property name=&quot;APP_NAME&quot; value=&quot;test-demo&quot; /&gt;</span><br><span class="line">    &lt;!--日志文件保留天数 --&gt;</span><br><span class="line">    &lt;property name=&quot;LOG_MAX_HISTORY&quot; value=&quot;30&quot; /&gt;</span><br><span class="line">    &lt;!--定义日志文件的存储地址 勿在 LogBack 的配置中使用相对路径 --&gt;</span><br><span class="line">    &lt;!--应用日志文件保存路径 --&gt;</span><br><span class="line">    &lt;property name=&quot;LOG_APP_HOME&quot; value=&quot;$&#123;LOG_HOME&#125;&quot; /&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!--=========================== 按照每天生成日志文件：默认配置=================================== --&gt;</span><br><span class="line">    &lt;!-- 控制台输出 --&gt;</span><br><span class="line">    &lt;appender name=&quot;STDOUT&quot; class=&quot;ch.qos.logback.core.ConsoleAppender&quot;&gt;</span><br><span class="line">        &lt;encoder class=&quot;ch.qos.logback.classic.encoder.PatternLayoutEncoder&quot;&gt;</span><br><span class="line">            &lt;!--格式化输出：%d表示日期，%thread表示线程名，%-5level：级别从左显示5个字符宽度%msg：日志消息，%n是换行符 --&gt;</span><br><span class="line">            &lt;pattern&gt;%d&#123;yyyy-MM-dd HH:mm:ss.SSS&#125; [%thread] %-5level %logger&#123;50&#125; - %msg%n&lt;/pattern&gt;</span><br><span class="line">        &lt;/encoder&gt;</span><br><span class="line">    &lt;/appender&gt;</span><br><span class="line">    &lt;!-- 文件输出 info --&gt;</span><br><span class="line">    &lt;appender name=&quot;fileInfoLog&quot; class=&quot;ch.qos.logback.core.rolling.RollingFileAppender&quot;&gt;</span><br><span class="line">        &lt;!--如果只是想要 Info 级别的日志，只是过滤 info 还是会输出 Error 日志，因为 Error 的级别高，</span><br><span class="line">        所以我们使用下面的策略，可以避免输出 Error 的日志--&gt;</span><br><span class="line">        &lt;filter class=&quot;ch.qos.logback.classic.filter.LevelFilter&quot;&gt;</span><br><span class="line">            &lt;!--过滤 Error--&gt;</span><br><span class="line">            &lt;level&gt;ERROR&lt;/level&gt;</span><br><span class="line">            &lt;!--匹配到就禁止--&gt;</span><br><span class="line">            &lt;onMatch&gt;DENY&lt;/onMatch&gt;</span><br><span class="line">            &lt;!--没有匹配到就允许--&gt;</span><br><span class="line">            &lt;onMismatch&gt;ACCEPT&lt;/onMismatch&gt;</span><br><span class="line">        &lt;/filter&gt;</span><br><span class="line">        &lt;!--日志名称，如果没有File 属性，那么只会使用FileNamePattern的文件路径规则</span><br><span class="line">            如果同时有&lt;File&gt;和&lt;FileNamePattern&gt;，那么当天日志是&lt;File&gt;，明天会自动把今天</span><br><span class="line">            的日志改名为今天的日期。即，&lt;File&gt; 的日志都是当天的。</span><br><span class="line">        --&gt;</span><br><span class="line">        &lt;!--&lt;File&gt;$&#123;logdir&#125;/%d&#123;yyyy-MM-dd&#125;/info.$&#123;appname&#125;.%d&#123;yyyy-MM-dd&#125;.log&lt;/File&gt;--&gt;</span><br><span class="line">        &lt;!--滚动策略，按照时间滚动 TimeBasedRollingPolicy--&gt;</span><br><span class="line">        &lt;rollingPolicy class=&quot;ch.qos.logback.core.rolling.TimeBasedRollingPolicy&quot;&gt;</span><br><span class="line">            &lt;!--文件路径,定义了日志的切分方式——把每一天的日志归档到一个文件中,以防止日志填满整个磁盘空间--&gt;</span><br><span class="line">            &lt;FileNamePattern&gt;$&#123;logdir&#125;/%d&#123;yyyy-MM-dd&#125;/info.%d&#123;yyyy-MM-dd&#125;.log&lt;/FileNamePattern&gt;</span><br><span class="line">            &lt;!--只保留最近90天的日志--&gt;</span><br><span class="line">            &lt;maxHistory&gt;$&#123;LOG_MAX_HISTORY&#125;&lt;/maxHistory&gt;</span><br><span class="line">            &lt;!--用来指定日志文件的上限大小，那么到了这个值，就会删除旧的日志--&gt;</span><br><span class="line">            &lt;!--&lt;totalSizeCap&gt;1GB&lt;/totalSizeCap&gt;--&gt;</span><br><span class="line">        &lt;/rollingPolicy&gt;</span><br><span class="line">        &lt;!--日志输出编码格式化--&gt;</span><br><span class="line">        &lt;encoder class=&quot;ch.qos.logback.classic.encoder.PatternLayoutEncoder&quot;&gt;</span><br><span class="line">            &lt;!--格式化输出：%d表示日期，%thread表示线程名，%-5level：级别从左显示5个字符宽度%msg：日志消息，%n是换行符 --&gt;</span><br><span class="line">            &lt;pattern&gt;%d&#123;yyyy-MM-dd HH:mm:ss.SSS&#125; [%thread] %-5level %logger&#123;500&#125; - %msg%n&lt;/pattern&gt;</span><br><span class="line">        &lt;/encoder&gt;</span><br><span class="line">    &lt;/appender&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- 文件输出 error --&gt;</span><br><span class="line">    &lt;appender name=&quot;fileErrorLog&quot; class=&quot;ch.qos.logback.core.rolling.RollingFileAppender&quot;&gt;</span><br><span class="line">        &lt;!--如果只是想要 Error 级别的日志，那么需要过滤一下，默认是 info 级别的，ThresholdFilter--&gt;</span><br><span class="line">        &lt;filter class=&quot;ch.qos.logback.classic.filter.ThresholdFilter&quot;&gt;</span><br><span class="line">            &lt;level&gt;Error&lt;/level&gt;</span><br><span class="line">        &lt;/filter&gt;</span><br><span class="line">        &lt;!--日志名称，如果没有File 属性，那么只会使用FileNamePattern的文件路径规则</span><br><span class="line">            如果同时有&lt;File&gt;和&lt;FileNamePattern&gt;，那么当天日志是&lt;File&gt;，明天会自动把今天</span><br><span class="line">            的日志改名为今天的日期。即，&lt;File&gt; 的日志都是当天的。 最好不要把&lt;File&gt;和&lt;FileNamePattern&gt;</span><br><span class="line">            同时配置，否则按天生产文件夹的日期会出现错误。</span><br><span class="line">        --&gt;</span><br><span class="line">        &lt;!--&lt;File&gt;$&#123;logdir&#125;/%d&#123;yyyy-MM-dd&#125;/error.$&#123;appname&#125;.log&lt;/File&gt;--&gt;</span><br><span class="line"></span><br><span class="line">        &lt;!--滚动策略，按照时间滚动 TimeBasedRollingPolicy--&gt;</span><br><span class="line">        &lt;rollingPolicy class=&quot;ch.qos.logback.core.rolling.TimeBasedRollingPolicy&quot;&gt;</span><br><span class="line">            &lt;!--文件路径,定义了日志的切分方式——把每一天的日志归档到一个文件中,以防止日志填满整个磁盘空间--&gt;</span><br><span class="line">            &lt;FileNamePattern&gt;$&#123;logdir&#125;/%d&#123;yyyy-MM-dd&#125;/error.$&#123;appname&#125;.%d&#123;yyyy-MM-dd&#125;.log&lt;/FileNamePattern&gt;</span><br><span class="line">            &lt;!--只保留最近90天的日志--&gt;</span><br><span class="line">            &lt;maxHistory&gt;$&#123;LOG_MAX_HISTORY&#125;&lt;/maxHistory&gt;</span><br><span class="line">            &lt;!--用来指定日志文件的上限大小，那么到了这个值，就会删除旧的日志--&gt;</span><br><span class="line">            &lt;!--&lt;totalSizeCap&gt;1GB&lt;/totalSizeCap&gt;--&gt;</span><br><span class="line">        &lt;/rollingPolicy&gt;</span><br><span class="line">        &lt;!--日志输出编码格式化--&gt;</span><br><span class="line">        &lt;encoder class=&quot;ch.qos.logback.classic.encoder.PatternLayoutEncoder&quot;&gt;</span><br><span class="line">            &lt;!--格式化输出：%d表示日期，%thread表示线程名，%-5level：级别从左显示5个字符宽度%msg：日志消息，%n是换行符 --&gt;</span><br><span class="line">            &lt;pattern&gt;%d&#123;yyyy-MM-dd HH:mm:ss.SSS&#125; [%thread] %-5level %logger&#123;500&#125; - %msg%n&lt;/pattern&gt;</span><br><span class="line">        &lt;/encoder&gt;</span><br><span class="line">    &lt;/appender&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!--指定最基础的日志输出级别--&gt;</span><br><span class="line">    &lt;root level=&quot;INFO&quot;&gt;</span><br><span class="line">        &lt;!--appender将会添加到这个loger--&gt;</span><br><span class="line">        &lt;appender-ref ref=&quot;STDOUT&quot;/&gt;</span><br><span class="line">        &lt;appender-ref ref=&quot;fileInfoLog&quot;/&gt;</span><br><span class="line">        &lt;appender-ref ref=&quot;fileErrorLog&quot;/&gt;</span><br><span class="line"></span><br><span class="line">    &lt;/root&gt;</span><br><span class="line">&lt;/configuration&gt;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;强制：&quot;&gt;&lt;a href=&quot;#强制：&quot; class=&quot;headerlink&quot; title=&quot;强制：&quot;&gt;&lt;/a&gt;强制：&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;【强制】应用中不可直接使用日志系统(Log4j、Logback)中的 API，而应依赖使用日志框架&lt;br&gt;SLF4J 中
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Redis</title>
    <link href="http://yoursite.com/2018/03/14/redis/"/>
    <id>http://yoursite.com/2018/03/14/redis/</id>
    <published>2018-03-14T15:26:01.512Z</published>
    <updated>2018-03-14T15:31:17.824Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h1><h2 id="REmote-DIctionary-Server-Redis"><a href="#REmote-DIctionary-Server-Redis" class="headerlink" title="REmote DIctionary Server(Redis)"></a>REmote DIctionary Server(Redis)</h2><ol><li>描述</li></ol><p>&emsp;&emsp;REmote DIctionary Server(Redis) 是一个由Salvatore Sanfilippo写的key-value存储系统。<br>Redis是一个开源(BSD许可)的使用ANSI C语言编写、遵守BSD协议、支持网络、可基于内存亦可持久化的日志型、Key-Value数据库，内存中的数据结构存储系统，它可以用作数据库、缓存和消息中间件。它支持多种类型的数据结构，如 字符串（strings）， 散列（hashes）， 列表（lists）， 集合（sets）， 有序集合（sorted sets） 与范围查询， bitmaps， hyperloglogs 和 地理空间（geospatial） 索引半径查询。 Redis 内置了 复制（replication），LUA脚本（Lua scripting）， LRU驱动事件（LRU eviction），事务（transactions） 和不同级别的 磁盘持久化（persistence）， 并通过 Redis哨兵（Sentinel）和自动 分区（Cluster）提供高可用性（high availability）<br>并提供多种语言的API。</p><ol><li>简介</li></ol><p>Redis 与其他 key - value 缓存产品有以下三个特点：</p><ul><li>Redis支持数据的持久化，可以将内存中的数据保存在磁盘中，重启的时候可以再次加载进行使用。</li><li>Redis不仅仅支持简单的key-value类型的数据，同时还提供list，set，zset，hash等数据结构的存储。</li><li>Redis支持数据的备份，即master-slave模式的数据备份。</li></ul><ol><li>优势</li></ol><ul><li>性能极高 – Redis能读的速度是110000次/s,写的速度是81000次/s 。</li><li>丰富的数据类型 – Redis支持二进制案例的 Strings, Lists, Hashes, Sets 及 Ordered Sets 数据类型操作。</li><li>原子 – Redis的所有操作都是原子性的，意思就是要么成功执行要么失败完全不执行。单个操作是原子性的。多个操作也支持事务，即原子性，通过MULTI和EXEC指令包起来。</li><li>丰富的特性 – Redis还支持 publish/subscribe, 通知, key 过期等等特性。</li></ul><h2 id="redis-启动"><a href="#redis-启动" class="headerlink" title="redis 启动"></a>redis 启动</h2><h3 id="1-直接启动"><a href="#1-直接启动" class="headerlink" title="1. 直接启动"></a>1. 直接启动</h3><p>&emsp;&emsp;进入redis根目录，执行命令:<br>加上‘&amp;’号使redis以后台程序方式运行</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./redis-server &amp;</span><br></pre></td></tr></table></figure><h4 id="2-通过指定配置文件启动"><a href="#2-通过指定配置文件启动" class="headerlink" title="2. 通过指定配置文件启动"></a>2. 通过指定配置文件启动</h4><p>&emsp;&emsp;可以为redis服务启动指定配置文件，例如配置为/etc/redis/6379.conf<br><br>&emsp;&emsp;进入redis根目录，输入命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./redis-server /etc/redis/6379.conf</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Redis&quot;&gt;&lt;a href=&quot;#Redis&quot; class=&quot;headerlink&quot; title=&quot;Redis&quot;&gt;&lt;/a&gt;Redis&lt;/h1&gt;&lt;h2 id=&quot;REmote-DIctionary-Server-Redis&quot;&gt;&lt;a href=&quot;#REmote-DIct
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Linux 笔记</title>
    <link href="http://yoursite.com/2018/03/14/linux/"/>
    <id>http://yoursite.com/2018/03/14/linux/</id>
    <published>2018-03-14T15:25:57.906Z</published>
    <updated>2018-03-14T15:31:17.820Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Linux-笔记"><a href="#Linux-笔记" class="headerlink" title="Linux 笔记"></a>Linux 笔记</h3><p>LINUX笔记：<br>最左边的 root 显示的是『目前使用者的账号』， 而 @ 之后接的 linux 则是『主机名称』，至于最右边的 ~ 则指的是 『目前所在的目录』，那么那个 # 则是我们常常讲的『提示字符』啦！<br>Tips: 那个 ~ 符号代表的是『使用者的家目录』的意思，他是个『变量！』这相关的意义我们会在后续的章节依序介绍到。举例来说，root 的家目录在 /root， 所以 ~ 就代表 /root 的意思～而 dmtsai 的家目录在 /home/dmtsai， 所以如果您以 dmtsai 登入时，他看到的 ~ 就会等于 /home/dmtsai 喔！<br>至于提示字符方面，在 Linux 当中，预设 root 的提示字符为 # ，而一般身份使用者的提示字符为 $ 。<br>开始下达指令：<br>其实整个指令下达的方式很简单，您只要记得几个重要的概念就可以了。 举例来说，你可以这样下达指令的：<br>[root@linux ~]# command [-options] parameter1 parameter2 …<br>指令 选项 参数(1) 参数(2)<br>说明：</p><ol><li>一行指令中第一个输入的绝对是『指令(command)』或『可执行档案』</li><li>command 为指令<br>的名称，例如变换路径的指令为 cd 等等；</li><li>中括号[]并不存在于实际的指令中，而加入参数设定时，通常为 - 号，例如 -h；<br>有时候完整参数名称会输入 – 符号，例如 –help；</li><li>parameter1 parameter2.. 为依附在 option 后面的参数，<br>或者是 command 的参数；</li><li>command, -options, parameter1.. 这几个咚咚中间以空格来区分，<br>不论空几格 shell 都视为一格；</li><li>按下 [Enter] 按键后，该指令就立即执行。[Enter] 按键为 <cr> 字符，<br>他代表着一行指令的开始启动。</cr></li><li>指令太长的时候，可以使用 \ 符号来跳脱 [Enter] 符号，<br>使指令连续到下一行。注意！ \ 后就立刻接特殊字符。<br>其它：<br>a. 在 Linux 系统中，英文大小写字母是不一样的。举例来说， cd 与 CD 并不同。<br>b. 更多的介绍等到 bash 时，再来详述。<br>• 显示日期的指令： date<br>• 显示日历的指令： cal<br>• 简单好用的计算器： bc<br>• [Tab] 按键<br>• [Tab] 接在一串指令的第一个字的后面，则为命令补全；<br>• [Tab] 接在一串指令的第二个字以后时，则为『档案补齐』！<br>[Tab] 按键就是在键盘的大写灯切换按键([Caps Lock])上面的那个按键！ 在各种 Unix-Like 的 Shell 当中，这个 [Tab] 按键算是 Linux 的 Bash shell 最棒的功能之一了！ 他具有『命令补全』与『档案补齐』的功能喔！可以让我们少打很多字，但重点是， 可以避免我们打错指令或文件名称呢！很棒吧！但是 [Tab] 按键在不同的地方输入，会有不一样的结果喔！ 我们举下面的例子来说明。上一小节我们不是提到 cal 这个指令吗？如果我在指令列输入 ca 再按两次 [tab] 按键，会出现什么讯息？<br>[root@linux ~]# ca[tab][tab] &lt;==[tab]按键是紧接在 a 字母后面！<h1 id="上面的-tab-指的是『按下那个tab键』，不是要您输入-ca-…-的意思喔！"><a href="#上面的-tab-指的是『按下那个tab键』，不是要您输入-ca-…-的意思喔！" class="headerlink" title="上面的 [tab] 指的是『按下那个tab键』，不是要您输入 ca[… 的意思喔！"></a>上面的 [tab] 指的是『按下那个tab键』，不是要您输入 ca[… 的意思喔！</h1>cadaver callgrind_control capiinit case<br>cal cancel capinfos cat<br>calibrate_ppa cancel.cups captoinfo catchsegv<br>caller capifax card<br>callgrind capifaxrcvd cardctl<br>callgrind_annotate capiinfo cardmgr<br>发现什么事？所有以 ca 为开头的指令都被显示出来啦！很不错吧！ 那如果你输入 ls -al ~/.bash 两个 [tab] 会出现什么？<br>[root@linux ~]# ls -al ~/.bash[tab][tab]<br>.bash_history .bash_logout .bash_profile .bashrc<br>• [Ctrl]-c 按键<br>中断程序按键<br>• [Ctrl]-d 按键<br>这个组合按键通常代表着： 『键盘输入结束 (End Of File, EOF 或 End Of Input)』的意思！ 另外，他也可以用来取代 exit 的输入呢！<br>Manual Page<br>manual 指令：查看帮助手册<br>一点来看这个 man page 的话， 您会发现几个有趣的东西。 首先，在上个表格的第一行，您可以看到的是：『DATE(1)』， DATE 我们知道是指令的名称， 那么 (1) 代表什么呢？他代表的是『一般使用者可使用的指令』的意思！咦！还有这个用意啊！！呵呵！ 没错～在查询数据的后面的数字是有意义的喔！他可以帮助我们了解或者是直接查询相关的资料。 常见的几个数字的意义是这样的：<br>代号<br>代表内容<br>1<br>使用者可以操作的指令或可执行文件<br>2<br>系统核心可呼叫的函数与工具等<br>3<br>一些常用的函数(function)与函式库(library)<br>4<br>装置档案的说明<br>5<br>设定档或者是某些档案的格式<br>6<br>游戏(games)<br>7<br>惯例与协议等，例如 Linux 标准档案系统、 网络协议、ASCII code 等等的说明内容<br>8<br>系统管理员可用的管理指令<br>9<br>跟 kernel 有关的文件<br>空格键<br>向下翻一页<br>[Page Down]<br>向下翻一页<br>[Page Up]<br>向上翻一页<br>[Home]<br>去到第一页<br>[End]<br>去到最后一页<br>/string<br>向『下』搜寻 string 这个字符串，如果要搜寻 vbird 的话，就输入 /vbird<br>?string<br>向『上』搜寻 string 这个字符串<br>n, N<br>利用 / 或 ? 来搜寻字符串时，可以用 n 来继续下一个搜寻 (不论是 / 或 ?) ，可以利用 N 来进行『反向』搜寻。举例来说，我以 /vbird 搜寻 vbird 字符串， 那么可以 n 继续往下查询，用 N 往上查询。若以 ?vbird 向上查询 vbird 字符串， 那我可以用 n 继续『向上』查询，用 N 反向查询。<br>q<br>结束这次的 man page。<br>LINUX关机的正确方法：<br>• 将数据同步写入硬盘中的指令： sync             –只有root管理员才可以执行。<br>• 惯用的关机指令： shutdown<br>• 重新开机，关机： reboot, halt, poweroff<br>shutdown：<br>-t sec ： -t 后面加秒数，亦即『过几秒后关机』的意思<br>-k ： 不要真的关机，只是发送警告讯息出去！<br>-r ： 在将系统的服务停掉之后就重新开机<br>-h ： 将系统的服务停掉后，立即关机。<br>-n ： 不经过 init 程序，直接以 shutdown 的功能来关机<br>-f ： 关机并开机之后，强制略过 fsck 的磁盘检查<br>-F ： 系统重新开机之后，强制进行 fsck 的磁盘检查<br>-c ： 取消已经在进行的 shutdown 指令内容。<br>多终端登录：<br>请问如果我以文字模式登入 Linux 主机时，我有几个终端机接口可以使用？如何切换各个不同的终端机接口？<br>共有六个， tty1 ~ tty6 ，切换的方式为 Crtl + Alt + [F1]~[F6]，其中， [F7] 为图形接口的使用。</li></ol><p>Linux 档案属性：<br>嗯！既然要让你了解 Linux 的档案属性，那么有个重要的也是常用的指令就必须要先跟你说啰！那一个？！就是『 ls 』这一个 list 档案的指令啰！在你以 root 的身份登入 Linux 之后，下达『ls -al 』看看，会看到底下的几个咚咚：<br>[root@linux ~]# ls -al<br>total 248<br>drwxr-x— 9 root root 4096 Jul 11 14:58 .<br>drwxr-xr-x 24 root root 4096 Jul 9 17:25 ..<br>-rw——- 1 root root 1491 Jun 25 08:53 anaconda-ks.cfg<br>-rw——- 1 root root 13823 Jul 10 23:12 .bash_history<br>-rw-r–r– 1 root root 24 Dec 4 2004 .bash_logout<br>-rw-r–r– 1 root root 191 Dec 4 2004 .bash_profile<br>-rw-r–r– 1 root root 395 Jul 4 11:45 .bashrc<br>-rw-r–r– 1 root root 100 Dec 4 2004 .cshrc<br>drwx—— 3 root root 4096 Jun 25 08:35 .ssh<br>-rw-r–r– 1 root root 68495 Jun 25 08:53 install.log<br>-rw-r–r– 1 root root 5976 Jun 25 08:53 install.log.syslog<br>[ 1 ][ 2 ][ 3 ][ 4 ][ 5 ][ 6 ][ 7 ]<br>[ 属性 ][连结][拥有者][群组][档案容量][ 修改日期 ][ 檔名 ]<br>ls 是『list』的意思，与在早期的 DOS 年代的指令 dir 类似功能。 而参数『-al』则表示列出所有的档案 ( 包含隐藏档，就是档名前面第一个字符为 . 的那种档案 ) 。如上所示，在你第一次以 root 身份登入 Linux 时，如果你输入指令后，应该有上列的几个东西， 先解释一下上面七个字段个别的意思：</p><ol><li>第一栏代表这个档案的属性： 这个地方最需要注意了！仔细看的话，你应该可以发现这一栏其实共有十个属性：</li></ol><p>o 第一个属性代表这个档案是『目录、档案或连结文件等等』：<br>􀂃 当为[ d ]则是目录，例如上表的第 11 行；<br>􀂃 当为[ - ]则是档案，例如上表的第 5 行；<br>􀂃 若是[ l ]则表示为连结档(link file)；<br>􀂃 若是[ b ]则表示为装置文件里面的可供储存的接口设备；<br>􀂃 若是[ c ]则表示为装置文件里面的串行端口设备，例如键盘、鼠标。<br>o 接下来的属性中，三个为一组，且均为『rwx』 的三个参数的组合。其中，[ r ]代表可读(read)、[ w ]代表可写(write)、[ x ]代表可执行(excute)：<br>􀂃 第一组为『拥有人的权限』，以第 5 行为例，该档案的拥有人可以读写，但不可执行；<br>􀂃 第二组为『同群组的权限』；<br>􀂃 第三组为『其它非本群组的权限』。<br>范例：若有一个档案的属性为『-rwxr-xr–』，简单的可由下面说明之：<br>[-][rwx][r-x][r–]<br>1 234 567 890<br>1 为：代表这个文件名为目录或档案（上面为档案）<br>234为：拥有人的权限（上面为可读、可写、可执行）<br>567为：同群组使用者权限（上面为可读可执行）<br>890为：其它使用者权限（上面为仅可读）<br>上面的属性情况代表一个档案、这个档案的拥有人可读可写可执行、但同群组的人仅可读与执行， 非同群组的使用者仅可读的意思！<br>2.第二栏表示为连接占用的节点(i-node):这个跟连结档(link file)比较有关系。<br>3.第三栏表示这个档案（或目录）的『拥有人』。<br>4.第四栏表示拥有人的群组。<br>5.第五栏为这个档案的容量大小。<br>6.第六栏为该档案的最近修改日期。<br>7.第七栏为这个档案的档名，如果档名前多一个【.】，则代表改文档为隐藏文档。<br>如果您想要开放某个目录让一些人进来的话， 请记得将该目录的 x 属性给开放呦！<br>• chgrp ：改变档案所属群组<br>• chown ：改变档案所属人<br>• chmod ：改变档案的属性、 SUID</p><p>• chgrp ：改变档案所属群组<br>改变一个档案的群组真是很简<br>嘛！对啦！这样就很好记了吧！ ^_^。不过，请记得， 要改变成为的群组名称必须要在 /etc/group 里面存在的名称才行，否则就会显示错误！<br>[root@linux ~]# chmod u=rwx,go=rx .bashrc</p><h1 id="注意喔！那个-u-rwx-go-rx-是连在一起的，中间没有空格符。"><a href="#注意喔！那个-u-rwx-go-rx-是连在一起的，中间没有空格符。" class="headerlink" title="注意喔！那个 u=rwx,go=rx 是连在一起的，中间没有空格符。"></a>注意喔！那个 u=rwx,go=rx 是连在一起的，中间没有空格符。</h1><p>可以用数字代表各个属性：<br>r:4<br>w:2<br>x:1</p><p>Linux的档案种类主要有以下几种：<br>• 正规档案 (regular file )： 就是一般我们在进行存取的类型的档案，在由 ls –al 所显示出来的属性方面，第一个属性为 [ - ]，例如 [-rwxrwxrwx ]。另外，依照档案的内容，又大略可以分为：<br>o 纯文字文件(ASCII)：这是 Unix 系统中最多的一种档案类型啰，称为纯文字文件是因为内容为我们人类可以直接读到的数据， 例如数字、字母等等。几乎只要我们可以用来做为设定的档案都属于这一种档案类型。 举例来说，您可以下达『 cat ~/.bashrc 』就可以看到该档案的内容。 (cat 是将一个档案内容读出来的指令)<br>o 二进制文件(binary)：还记得我们在『 Linux 是什么 』那一章里面的 GNU 发展史中提过， 我们的系统其实仅认识且可以执行二进制档案 (binary file) 吧？没错～ 您的 Linux 当中的可执行档 (scripts, 文字型批次文件不算) 就是这种格式的啦～ 举例来说，刚刚下达的指令 cat 就是一个 binary file 。<br>o 数据格式文件(data)： 有些程序在运作的过程当中会读取某些特定格式的档案，那些特定格式的档案可以被称为数据文件 (data file)。举例来说，我们的 Linux 在使用者登入时，都会将登录的数据记录在 /var/log/wtmp 那个档案内，该档案是一个 data file ，他能够透过 last 这个指令读出来！ 但是使用 cat 时，会读出乱码～因为他是属于一种特殊格式的档案。瞭乎？<br>• 目录 (directory)：就是目录啰～第一个属性为 [ d ]，例如 [drwxrwxrwx]。<br>• 连结档 (link)：就是类似 Windows 底下的快捷方式啦！第一个属性为 [ l ]， 例如 [lrwxrwxrwx] ；<br>• 设备与装置文件 (device)：与系统周边及储存等相关的一些档案， 通常都集中在 /dev 这个目录之下！通常又分为两种：<br>o 区块 (block) 设备档 ：就是一些储存数据， 以提供系统存取的接口设备，简单的说就是硬盘啦！例如你的一号硬盘的代码是 /dev/hda1 等等的档案啦！第一个属性为 [ b ]；<br>o 字符 (character) 设备档 ：亦即是一些串行端口的接口设备， 例如键盘、鼠标等等！第一个属性为 [ c ]。<br>•资料接口文件 (sockets)：既然被称为数据接口文件， 想当然尔，这种类型的档案通常被用在网络上的数据承接了。我们可以启动一个程序来监听客户端的要求， 而客户端就可以透过这个 socket 来进行数据的沟通了。第一个属性为 [ s ]， 最常在 /var/run 这个目录中看到这种档案类型了。<br>• 数据输送文件 (FIFO, pipe)： FIFO 也是一种特殊的档案类型，他主要的目的在解决多个程序同时存取一个档案所造成的错误问题。 FIFO 是 first-in-first-out 的缩写。第一个属性为 [p] 。<br>有数种常用的附档名：<br>• <em>.sh ： 批次檔 ( scripts )，因为批次档为使用 shell 写成的，所以附档名就编成 .sh 啰；<br>• </em>Z, <em>.tar, </em>.tar.gz, <em>.zip, </em>.tgz： 经过打包的压缩档。这是因为压缩软件分别为 gunzip, tar 等等的，由于不同的压缩软件，而取其相关的附档名啰！<br>• <em>.html, </em>.php：网页相关档案，分别代表 HTML 语法与 PHP 语法的网页档案啰！ .html 的档案可使用网页浏览器来直接开启，至于 .php 的档案， 则可以透过 client 端的浏览器来 server 端浏览，以得到运算后的网页结果呢！<br>Linux 在文字接口下的一些指令操作关系，一般来说，您在设定 Linux 底下的文件名称时， 最好可以避免一些特殊字符比较好！例如底下这些：</p><ul><li>? &gt; &lt; ; &amp; ! [ ] | \ ‘ “ ` ( ) { }<br>FHS：<br>这个 FHS ( <a href="http://www.pathname.com/fhs/" target="_blank" rel="noopener">http://www.pathname.com/fhs/</a> ) 事实上仅是规范出在根目录 ( / ) 底下各个主要的目录应该是要放置什么样的档案而已。 FHS 定义出两层规范出来，第一层是 / 底下的各个目录应该要放置什么样内容的档案数据，例如 /etc 应该要放置设定档， /bin 与 /sbin 则应该要放置可执行档等等。第二层则是针对 /usr 及 /var 这两个目录的次目录来定义的。 例如 /var/log 放置系统登录文件、 /usr/share 放置共享数据等等。<br>目录树：<br>Linux 底下，所有的档案与目录都是由根目录 / 开始的！那是所有目录与档案的源头～ 然后再一个一个的分支下来，有点像是树枝状啊～因此，我们也称这种目录配置方式为：『目录树 (directory tree)』<br>文档名的书写：<br>根据档名写法的不同，也可将所谓的路径 (path) 定义为绝对路径 (absolute) 与相对路径 (relative)。 绝对路径为：由根目录 (/) 开始写起的文件名或目录名称， 例如 /home/dmtsai/.bashrc；相对路径为相对于目前路径的文件名写法。 例如 ./home/dmtsai 或 ../../home/dmtsai/ 等等。反正开头不是 / 就属于相对路径的写法， 而您必须要了解，相对路径是以『您当前所在路径的相对位置』来表示的。举例来说，您目前在 /home 这个目录下， 如果想要进入 /var/log 这个目录时，可以怎么写呢？<br>• cd /var/log (absolute)<br>• cd ../var/log (relative)<br>因为您在 /home 底下，所以要回到上一层 (../) 之后，才能继续往 /var 来移动的！ 特别注意这两个特殊的目录：<br>• . ：代表当前的目录，也可以使用 ./ 来表示；<br>• .. ：代表上一层目录，也可以 ../ 来代表。<br>这个 . 与 .. 目录概念是很重要的，您常常会看到 cd .. 或 ./command 之类的指令下达方式， 就是代表上一层与目前所在目录的工作状态喔！很重要的吶！此外，针对『档名』与『完整档名 (由 / 开始写起的文件名)』 的字符限制大小为：<br>• 单一档案或目录的最大容许文件名为 255 个字符；<br>• 包含完整路径名称及目录 (/) 之完整档名为 4096 个字符。</li></ul><p>如果以『账号』的角度来看，所谓的 root 指的是『系统管理员！』的身份， 如果以『目录』的角度来看，所谓的 root 意即指的是根目录。<br>Linux目录结构：</p><p>请注意，每个目录都是依附在 / 这个根目录底下的，所以我们在安装的时候一定要有一个 / 对应的 partition 才能安装的原因即在于此！这也就是我们俗称的『树状目录』啰！而根据 FHS 定义出来的每个目录内应该放置的档案内容为：<br>目录<br>应放置档案内容<br>/<br>根目录 root (/)，一般建议在根目录底下只接目录，不要直接有档案在 / 底下。 根目录是开机的时候系统第一个挂载的 partition ，所以，所有开机过程会用到的档案， 应该都要放置在这个 partition 当中。举例来说，/etc, /bin, /dev, /lib, /sbin 这五个次目录都应该要与根目录连在一起，不可独立成为某个 partition 呢！<br>/bin, /usr/bin, /usr/local/bin<br>除了 /bin 之外， /usr/local/bin, /usr/bin 也是放置『使用者可执行的 binary file 的目录』喔！举例来说，ls, mv, rm, mkdir, rmdir, gzip, tar, cat, cp, mount 等等重要指令都放在这个目录当中。<br>/boot<br>这个目录主要的目的是放置 Linux 系统开机会用到的档案。 开机会用到什么呢？没错～就是 Linux 的核心档案。这个目录底下文件名为 vmlinuz 的就是 Linux 的 Kernel 啦！粉重要的东西！ 而如果你的开机管理程序 (loader) 选择 grub 的话，那么这个目录内还有 /boot/grub 这个次目录呦！<br>/dev<br>在 Linux 系统上，任何装置与接口设备都是以档案的型态存在于这个目录当中的。 您只要透过存取这个目录底下的某个档案，就等于存取某个装置啰～ 主要又分为接口设备 (character device)，例如键盘、鼠标等；以及储存设备 (block device)， 例如硬盘、光盘等等。在此目录下的档案会多出两个属性，分别是 major device number ， 与 minor device number 。我们的系统核心就是透过这两个 number 来判断装置的呢！ 比要重要的档案有 /dev/null, /dev/tty[1-6], /dev/ttyS<em>, /dev/lp</em>, /dev/hd<em>, /dev/sd</em> 等等<br>/etc<br>系统主要的设定文件几乎都放置在这个目录内，例如人员的账号密码文件、 各种服务的启始档等等。一般来说，这个目录下的各档案属性是可以让一般使用者查阅的， 但是只有 root 有权力修改。并且在此目录下的档案几乎都是 ASCII 的纯文本文件哩。 不过， FHS 建议不要放置可执行文件在这个目录中喔。比较重要的档案有： /etc/inittab, /etc/init.d/, /etc/modprobe.conf, /etc/X11, /etc/fstab, /etc/sysconfig/ 等等。另外，其下重要的目录有：<br>• /etc/init.d/：所有服务的预设启动 script 都是放在这里的，例如要启动或者关闭 iptables 的话： /etc/init.d/iptables start /etc/init.d/iptables stop<br>• /etc/xinetd.d/：这就是所谓的 super daemon 管理的各项服务的设定文件目录。<br>• /etc/X11：与 X Window 有关的各种设定档都在这里，尤其是 xorg.conf 或 XF86Config 这两个 X Server 的设定档。<br>/home<br>这是系统预设的使用者家目录 (home directory)。在你新增一个一般使用者账号时， 预设的使用者家目录都会规范到这里来。比较重要的是，家目录有两种代号喔： ~：代表目前这个使用者的家目录，而 ~dmtsai ：则代表 dmtsai 的家目录！<br>/lib, /usr/lib, /usr/local/lib<br>系统会使用到的函式库放置的目录。 程序在运作的过程中，可能会呼叫一些额外的功能参数，那需要函式库的协助！ 这些函式库就放在此处。比较重要的是 /lib/modules 这个目录内会摆放 kernel 的相关模块喔！<br>/lost+found<br>系统不正常产生错误时，会将一些遗失的片段放置于此目录下， 通常这个目录会自动出现在某个 partition 最顶层的目录下。例如你加装一棵硬盘于 /disk 中， 那在这个目录下就会自动产生一个这样的目录 /disk/lost+found<br>/mnt /media<br>这是软盘与光盘预设挂载点的地方；通常软盘挂在 /mnt/floppy 下，而光盘挂在 /mnt/cdrom 下，不过也不一定啦！只要你高兴，随便找一个地方来挂载也可以呀！另外，目前也规划出另一个 /media 的目录呢！与 /mnt 有点类似啦～<br>/opt<br>这是给主机额外安装软件所摆放的目录。举例来说， FC4 使用的是 Fedora 社群开发的软件， 如果您今天想要自行安装新的 KDE 桌面软件的话，可以将该软件安装在这个目录下的意思。 不过，以前的 Linux 系统中，我们还是习惯放置在 /usr/local 目录下呢！<br>/proc<br>这个目录本身是一个『虚拟档案系统』喔！他放置的数据都是在内存当中， 例如系统核心、形成信息、接口设备的状态及网络状态等等。因为这个目录下的数据都是在内存当中， 所以本身不占任何硬盘空间啊！比较重要的档案例如：/proc/cpuinfo, /proc/dma, /proc/interrupts, /proc/ioports, /proc/net/<em> 等等。<br>/root<br>系统管理员 (root) 的家目录。之所以放在这里， 是因为我们提过，系统第一个开机就被挂载的 partition 为 / ， 而我们希望 /root 能够与 / 放在同一块 partition 上面之故。<br>/sbin, /usr/sbin, /usr/local/sbin<br>放置一些系统管理员才会动用到的执行指令，例如： fdisk, mke2fs, fsck, mkswap, mount 等等。与 /bin 不太一样的地方，这几个目录是给 root 等系统管理用的。但是本目录下的执行文件还是可以让一般使用者用来『察看』而不能设定喔！<br>/srv<br>一些服务启动之后，这些服务所需要取用的数据目录。举例来说，WWW 服务器需要的网页资料就可以放置在 /srv/www 里面。<br>/tmp<br>这是让一般使用者或者是正在执行的程序暂时放置档案的地方。 这个目录是任何人都能够存取的，所以您需要定期的清理一下。当然，重要数据不可放置在此目录啊！<br>/usr<br>由 FHS 规范的第二层内容，在 /usr 此目录下，包含系统的主要程序、 图形接口所需要的档案、额外的函式库、本机端所自行安装的软件，以及共享的目录与文件等等， 都可以在这个目录当中发现。事实上，他有点像是 Windows 操作系统当中的『Program files』与 『WinNT』这两个目录的结合！在此目录下的重要次目录有：<br>• /usr/bin, /usr/sbin：一般身份使用者与系统管理员可执行的档案放置目录；<br>• /usr/include：c/c++等程序语言的档头 (header) 与包含档(include)放置处， 当我们以 tarball 方式 (</em>.tar.gz 的方式安装软件) 安装某些数据时，会使用到里头的许多包含档喔！；<br>• /usr/lib：各应用软件的函式库档案放置目录；<br>• /usr/local：本机端自行安装的软件预设放置的目录。目前也适用于 /opt 目录。 在你安装完了 Linux 之后，基本上所有的配备你都有了，但是软件总是可以升级的， 例如你要升级你的 proxy 服务，则通常软件预设的安装地方就是在 /usr/local (local 是『当地』的意思)，同时，安装完毕之后所得到的执行文件，为了与系统原先的执行文件有分别， 因此升<br>级后的执行档通常摆在 /usr/local/bin 这个地方。给个建议啦， 通常鸟哥都会将后来才安装上去的软件放置在这里，因为便于管理呦；<br>• /usr/share：共享文件放置的目录，例如底下两个目录：<br>• /usr/share/doc：放置一些系统说明文件的地方，例如你安装了 grub 了，那么在该目录底下找一找，就可以查到 lilo 的说明文件了！很是便利！<br>• /usr/share/man：manpage 的文件档案目录；那是什么？呵呵！ 就是你使用 man 的时候，会去查询的路径呀！例如你使用 man ls 这个指令时，就会查出 /usr/share/man/man1/ls.1.gz 这个说明档的内容啰！<br>• /usr/src：Linux 系统相关的程序代码放置目录，例如/usr/src/linux 为核心原始码！<br>• /usr/X11R6：系统内的 X Window System 所需的执行档几乎都放在这！<br>/var<br>这个目录也很重要，也是 FHS 规范的第二层目录内容。他主要放置的是针对系统执行过程中， 常态性变动的档案放置的目录。举例来说，例如快取档案 (cache) 或者是随时变更的登录档 (log file) 都是放在这个目录中的。此外，某些软件执行过程中会写入的数据库档案， 例如 MySQL 数据库，也都写入在这个目录中！很重要吧！他底下的重要目录有：<br>• /var/cache：程序档案在运作过程当中的一些暂存盘；<br>• /var/lib：程序本身执行的过程中，需要使用到的数据文件放置的目录， 举例来说， locate 这个数据库与 MySQL 及 rpm 等数据库系统，都写在这个目录内。<br>• /var/log：登录文件放置的目录。很重要啊！例如 /var/log/messages 就是总管所有登录档的一个档案！<br>• /var/lock：某些装置具有一次性写入的特性，例如 tab (磁带机)， 此时，为了担心被其它人干扰而破坏正在运作的动作，因此，会将该装置 lock (锁住)起来， 以确定该装置只能被单一个程序所使用啊！<br>• /var/run：某些程序或者是服务启动后，会将他们的 PID 放置在这个目录下喔！<br>• /var/spool：是一些队列数据存放的地方。举例来说，主机收到电子邮件后， 就会放置到 /var/spool/mail 当中，若信件暂时发不出去，就会放置到 /var/spool/mqueue 目录下， 使用者工作排程 (cron) 则是放置在 /var/spool/cron 当中！<br>磁盘分布：<br>你或许可以将你的系统做成这样的 partition 分布：<br>/<br>/boot<br>/usr<br>/home<br>/var<br>这是比较常见的磁盘分布情况，其中：<br>• / 根目录可以分配约 1 GB 以内；<br>• /boot 大概在 50 MB 就可以了，因为开机档案并不大；<br>• /var 就至少需要 1GB 以上，因为你的 mail 、 proxy 预设的储存区都在这个目录中，除非你要将一些设定改变！<br>• /home 与 /usr 通常是最大的，因为你所安装的数据都是在 /usr/ 当中，而用户数据则放置在 /home 当中，因此通常大家都会建议你将所剩下的磁盘空间平均分配给这两个目录说！ 不过也不一定啦！ /usr 大概给个 10G 就很多了～其它的可以都给 /home ，也可以保留一些剩余空间来作为以后的安装与设定用啊！</p><p>硬盘挂载：IDE的英文全称为“Integrated Drive Electronics”，即“电子集成驱动器”<br>在我们添加硬盘前，首先要了解linux系统下对硬盘和分区的命名方法。在Linux下对IDE的设备是以hd命名的，第一个ide设备是hda，第二个是hdb。依此类推 我们一般主板上有两个IDE接口，一共可以安装四个IDE设备。主IDE上的两个设备分别对应hda和hdb，第二个IDE口上的两个设备对应hdc和hdd。 一般我们的硬盘安装在主IDE的主接口上，所以是hda，光驱一般安装在第二个IDE的主接口上，所以是hdc(应为hdb是用来命名主IDE上的从接口)，SCSI接口设备是用sd命名的，第一个设备是sda，第二个是sdb。依此类推 分区是用设备名称加数字命名的。例如hda1代表hda这个硬盘设备上的第一个分区。每个硬盘可以最多有四个主分区，作用是1-4命名硬盘的主分区。逻辑分区是从5开始的，每多一个分区，数字加以就可以。 比如我们一般的系统都有一个主分区用来引导系统，这个分区对应我们常说的C区，在linux下命名是hda1。后面我们分三个逻辑分区对应常说的D、E、F，在linux下命名是hda5、hda6、hda7 给硬盘分区 在slackware下有两个分区软件fdisk和cfdisk，例如我们已经有一个硬盘了，现在添加另一个硬盘到系统，那么我们根据命名规则知道这个新添加的硬盘应该是hdb。我们用下面命令给硬盘分区<br>fdisk /dev/hdb<br>你也可以用cfdisk来分区，命令如下：<br>cfdisk /dev/hdb<br>格式化硬盘 格式化成ext3格式<br>mkfs.ext3 /dev/hdb1<br>格式化成reiserfs的格式<br>mkfs.reiserfs /dev/hdb1<br>让硬盘启动自动挂载 例如挂载/dev/hdb1分区到/mnt/hd目录下 用vi编辑/etc/fstab文件，加入如下内容<br>/dev/dhb1 /mnt/hd reiserfs defaults 1 1<br>以前初识Linux时，对Linux系统安装时分区的选择，一点都不了解，导致几次没法进行下一步安装，因此就静下心来，专门拿出时间研究了研究这方面的知识；<br>以下内容就是以前通过研究Linux安装过程中分区的知识总结出来的一些知识；贴上来，做个备份，也希望对Linux初学者有一些帮助。<br>正文：<br>一般来说，在linux系统中都有最少两个挂载点，分别是/ (根目录)及 swap（交换分区），其中，/ 是必须的；<br>详细内容见下文：<br>建议挂载的几大目录：<br>/——-根目录，唯一必须挂载的目录。不要有任何的犹豫，选一个分区，挂载它！（在绝大多数情况下  有2G的容量应该是够用了。当然了，很多东西都是多多益善的）<br>swap—-交换分区，可能不是必须的，不过按照传统，并且照顾到您的安全感，还是挂载它吧。它的容量  只要约等于您的物理内存就可以了，如果超过了您物理内存两倍的容量，那绝对是一种浪费。<br>/home—这是您的家目录，通常您自己创建的文件，都保存在这里，您最好给它分配一个分区<br>/usr—-应用程序目录。大部分的软件都安装在这里，如果您计划安装许多软件，建议也给它分配一个分区<br>/var—-如果您要作一些服务器方面的应用，可以考虑给它分配一个较大的分区<br>/boot—如果您的硬盘不支持LBA模式（不太可能），您最好挂载它，如果挂载，将它挂载在硬盘的第一个  分区，应该比较稳妥。一般来说，挂载的分区只要100M大小就足够了</p><p>是否要将这几个挂载点独立分割出来则视你的规划需求而定。可参考以下建议：<br>1.初次接触的新手或硬盘空间有限Desktop的安装建议：<br>   挂载点        装置                      说明<br>     /           /dev/hda1        可用空间-swap大小后的所有空间<br>   swap       /dev/hda2         大约内存大小 建议至少512MB<br>2.高级用户Desktop的安装建议：<br>       挂载点        装置                      说明<br>　 　/               /dev/hda1                10~15G足矣<br> 　　/home       /dev/hda2              最大的剩余空间<br>　 　swap         /dev/hda5         大约内存大小(建议至少512MB)<br>或者<br>       /               /dev/hda1                10~15G足矣<br>      /home       /dev/hda2              最大的剩余空间<br>      /boot        /dev/hda3                 100MB即可<br>      swap         /dev/hda5         大约内存大小(建议至少512MB)<br>3.高级Server用户的安装建议：<br>   挂载点           装置                      说明<br>     /               /dev/hda1               10~15G足矣<br>    /home       /dev/hda2              最大的剩余空间<br>    /boot         /dev/hda3                100MB即可<br>    swap         /dev/hda5        大约内存大小(建议至少512MB)<br>    /var          /dev/hda6      视服务器功能决定大小，至少需要1GB以上<br>或者<br>    /                 /dev/hda1               10~15G足矣<br>   /home         /dev/hda2              最大的剩余空间的一半<br>   /boot          /dev/hda3                100MB即可<br>   swap           /dev/hda5        大约内存大小(建议至少512MB)<br>   /var            /dev/hda6      视服务器功能决定大小，至少需要1GB以上<br>   /usr            /dev/hda7              最大的剩余空间的一半<br>grep命令：<br>Linux系统中grep命令是一种强大的文本搜索工具，它能使用正则表达式搜索文本，并把匹 配的行打印出来。grep全称是Global Regular Expression Print，表示全局正则表达式版本，它的使用权限是所有用户。<br>2.格式<br>grep [options]<br>3.主要参数<br>[options]主要参数：<br>－c：只输出匹配行的计数。<br>－I：不区分大 小写(只适用于单字符)。<br>－h：查询多文件时不显示文件名。<br>－l：查询多文件时只输出包含匹配字符的文件名。<br>－n：显示匹配行及 行号。<br>－s：不显示不存在或无匹配文本的错误信息。<br>－v：显示不包含匹配文本的所有行。<br>pattern正则表达式主要参数：<br>\： 忽略正则表达式中特殊字符的原有含义。<br>^：匹配正则表达式的开始行。<br>$: 匹配正则表达式的结束行。<br>\&lt;：从匹配正则表达 式的行开始。<br>>：到匹配正则表达式的行结束。<br>[ ]：单个字符，如[A]即A符合要求 。<br>[ - ]：范围，如[A-Z]，即A、B、C一直到Z都符合要求 。<br>。：所有的单个字符。</p><ul><li>：有字符，长度可以为0。<br>• cd：变换目录 change directory<br>• pwd：显示目前的目录 print working directory<br>• mkdir：建立一个新的目录 make directory<br>• rmdir：删除一个空的目录 remove directory</li></ul><p>复制、移动与删除： cp, rm, mv<br>cp不允许相对路径。靠<br>cp：路径+文件，文件，路径。日<br>linux命令ls会显示出文件的颜色, 系统约定的默认颜色含义如下:<br>白色：表示普通文件<br>蓝色：表示目录<br>绿色：表示可执行文件<br>红色：表示压缩文件<br>浅蓝色：链接文件<br>红色闪烁：表示链接的文件有问题<br>黄色：表示设备文件<br>灰色：表示其他文件<br>取得路径的文件名称与目录名称：basename dirname<br>档案内容查阅：<br>读取文本：cat (concatenate) tac more less head tail。<br>读取文件：od<br>查找文件：locate whereis （从系统数据库中读取数据，可能未更新的数据查找不到）find（从硬盘读取。准确但是速度较慢。）<br>档案预设权限：umask umask -S<br>一种可以直接输入 umask ，就可以看到数字型态的权限设定分数， 一种则是加入 -S (Symbolic) 这个参数，就会以符号类型的方式来显示出权限了！ 奇怪的是，怎么 umask 会有四组数字啊？不是只有三组吗？是没错啦～ 第一组是特殊权限用的.<br>例题四：假设您的 umask 为 003 ，请问该 umask 情况下，建立的档案与目录权限为？ 答：<br>umask 为 003 ，所以拿掉的属性为 ——–wx，因此： 档案： (-rw-rw-rw-) - (——–wx) = -rw-rw-r– 目录： (drwxrwxrwx) - (——–wx) = drwxrwxr–<br>档案隐藏属性：<br>• chattr (设定档案隐藏属性)<br>[root@linux ~]# chattr [+-=][ASacdistu] 档案或目录名称<br>参数：</p><ul><li>：增加某一个特殊参数，其它原本存在参数则不动。</li></ul><ul><li>：移除某一个特殊参数，其它原本存在参数则不动。<br>= ：设定一定，且仅有后面接的参数<br>A ：当设定了 A 这个属性时，这个档案(或目录)的存取时间 atime (access)<br>将不可被修改，可避免例如手提式计算机容易有磁盘 I/O 错误的情况发生！<br>S ：这个功能有点类似 sync 的功能！就是会将数据同步写入磁盘当中！<br>可以有效的避免数据流失！<br>a ：当设定 a 之后，这个档案将只能增加数据，而不能删除，只有 root<br>才能设定这个属性。<br>c ：这个属性设定之后，将会自动的将此档案『压缩』，在读取的时候将会自动解压缩，<br>但是在储存的时候，将会先进行压缩后再储存(看来对于大档案似乎蛮有用的！)<br>d ：当dump(备份)程序被执行的时候，设定 d 属性将可使该档案(或目录)不具有dump功能<br>i ：这个 i 可就很厉害了！他可以让一个档案『不能被删除、改名、设定连结也无法写入<br>或新增资料！』对于系统安全性有相当大的帮助！<br>j ：当使用 ext3 这个档案系统格式时，设定 j 属性将会使档案在写入时先记录在<br>journal 中！但是当 filesystem 设定参数为 data=journalled 时，由于已经设定了<br>日志了，所以这个属性无效！<br>s ：当档案设定了 s 参数时，他将会被完全的移除出这个硬盘空间。<br>u ：与 s 相反的，当使用 u 来设定档案时，则数据内容其实还存在磁盘中，<br>可以使用来 undeletion.<br>注意：这个属性设定上面，比较常见的是 a 与 i 的设定值，而且很多设定值必须要身为<br>root 才能够设定的喔！<br>范例：<br>[root@linux ~]# cd /tmp<br>[root@linux tmp]# touch attrtest<br>[root@linux tmp]# chattr +i attrtest<br>[root@linux tmp]# rm attrtest<br>rm: remove write-protected regular empty file <code>attrtest&#39;? yrm: cannot remove</code>attrtest’: Operation not permitted<h1 id="看到了吗？呼呼！连-root-也没有办法将这个档案删除呢！赶紧解除设定！"><a href="#看到了吗？呼呼！连-root-也没有办法将这个档案删除呢！赶紧解除设定！" class="headerlink" title="看到了吗？呼呼！连 root 也没有办法将这个档案删除呢！赶紧解除设定！"></a>看到了吗？呼呼！连 root 也没有办法将这个档案删除呢！赶紧解除设定！</h1>[root@linux tmp]# chattr -i attrtest<br>• lsattr (显示档案隐藏属性)<br>[root@linux ~]# lsattr [-aR] 档案或目录<br>参数：<br>-a ：将隐藏文件的属性也秀出来；<br>-R ：连同子目录的数据也一并列出来！<br>范例：<br>[root@linux tmp]# chattr +aij attrtest<br>[root@linux tmp]# lsattr<br>—-ia—j— ./attrtest<br>档案特殊权限： SUID/SGID/Sticky Bit</li></ul><p>第二章<br>Linux 系统常见的压缩指令： 2.1 compress 2.2 gzip, zcat 2.3 bzip2, bzcat 2.4 tar 2.5 dd 2.6 cpio<br>gzip, zcat：[root@linux ~]# gzip [-cdt#] 檔名<br>[root@linux ~]# zcat 檔名.gz<br>参数：<br>-c ：将压缩的数据输出到屏幕上，可透过数据流重导向来处理；<br>-d ：解压缩的参数；<br>-t ：可以用来检验一个压缩档的一致性～看看档案有无错误；<br>-# ：压缩等级，-1 最快，但是压缩比最差、-9 最慢，但是压缩比最好！预设是 -6 ～<br>范例：<br>范例一：将 /etc/man.config 复制到 /tmp ，并且以 gzip 压缩<br>[root@linux ~]# cd /tmp<br>[root@linux tmp]# cp /etc/man.config .<br>[root@linux tmp]# gzip man.config</p><h1 id="此时-man-config-会变成-man-config-gz-！"><a href="#此时-man-config-会变成-man-config-gz-！" class="headerlink" title="此时 man.config 会变成 man.config.gz ！"></a>此时 man.config 会变成 man.config.gz ！</h1><p>范例二：将范例一的档案内容读出来！<br>[root@linux tmp]# zcat man.config.gz</p><h1 id="此时屏幕上会显示-man-config-gz-解压缩之后的档案内容！！"><a href="#此时屏幕上会显示-man-config-gz-解压缩之后的档案内容！！" class="headerlink" title="此时屏幕上会显示 man.config.gz 解压缩之后的档案内容！！"></a>此时屏幕上会显示 man.config.gz 解压缩之后的档案内容！！</h1><p>范例三：将范例一的档案解压缩<br>[root@linux tmp]# gzip -d man.config.gz<br>范例四：将范例三解开的 man.config 用最佳的压缩比压缩，并保留原本的档案<br>[root@linux tmp]# gzip -9 -c man.config &gt; man.config.gz<br>gzip 是用来压缩与解压缩附档名为 <em>.gz 的指令！所以看到 </em>.gz 的档案时，就应该要知道他是经由 gzip 这个程序压缩的呦！另外， gzip 也提供 压缩比的服务！ -1 是最差的压缩比，但是压缩速度最快，而 -9<br>虽然可以达到较佳的压缩比 (经过压缩之后，档案比较小一些！) ，但是却会损失一些速度！预设是 -6 这个数值！ gzip 也是相当常使用的一个压缩指令呢！ 至于 zcat 则是用来读取压缩文件数据内容的指令！假如我们刚刚压缩的档案是一个文字文件， 那么你还记得如何读取文字文件吗？！没错！就是使用 cat ，那么读取压缩档呢？呵呵！就是使用 zcat 啰！由于 gzip 这个压缩指令主要想要用来取代 compress 的，所以 compress 的压缩档案也可以使用 gzip 来解开喔！同时， zcat 这个指令可以同时读取 compress 与 gzip 的压缩档呦！<br>bzip2, bzcat：<br>[root@linux ~]# bzip2 [-cdz] 檔名<br>[root@linux ~]# bzcat 檔名.bz2<br>参数：<br>-c ：将压缩的过程产生的数据输出到屏幕上！<br>-d ：解压缩的参数<br>-z ：压缩的参数<br>-# ：与 gzip 同样的，都是在计算压缩比的参数， -9 最佳， -1 最快！<br>范例：<br>范例一：将刚刚的 /tmp/man.config 以 bzip2 压缩<br>[root@linux tmp]# bzip2 -z man.config</p><h1 id="此时-man-config-会变成-man-config-bz2-！"><a href="#此时-man-config-会变成-man-config-bz2-！" class="headerlink" title="此时 man.config 会变成 man.config.bz2 ！"></a>此时 man.config 会变成 man.config.bz2 ！</h1><p>范例二：将范例一的档案内容读出来！<br>[root@linux tmp]# bzcat man.config.bz2</p><h1 id="此时屏幕上会显示-man-config-bz2-解压缩之后的档案内容！！"><a href="#此时屏幕上会显示-man-config-bz2-解压缩之后的档案内容！！" class="headerlink" title="此时屏幕上会显示 man.config.bz2 解压缩之后的档案内容！！"></a>此时屏幕上会显示 man.config.bz2 解压缩之后的档案内容！！</h1><p>范例三：将范例一的档案解压缩<br>[root@linux tmp]# bzip2 -d man.config.bz2<br>范例四：将范例三解开的 man.config 用最佳的压缩比压缩，并保留原本的档案<br>[root@linux tmp]# bzip2 -9 -c man.config &gt; man.config.bz2<br>tar：<br>[root@linux ~]# tar [-cxtzjvfpPN] 档案与目录 ….<br>参数：<br>-c ：建立一个压缩档案的参数指令(create 的意思)；<br>-x ：解开一个压缩档案的参数指令！<br>-t ：查看 tarfile 里面的档案！<br>特别注意，在参数的下达中， c/x/t 仅能存在一个！不可同时存在！<br>因为不可能同时压缩与解压缩。<br>-z ：是否同时具有 gzip 的属性？亦即是否需要用 gzip 压缩？<br>-j ：是否同时具有 bzip2 的属性？亦即是否需要用 bzip2 压缩？<br>-v ：压缩的过程中显示档案！这个常用，但不建议用在背景执行过程！<br>-f ：使用档名，请留意，在 f 之后要立即接档名喔！不要再加参数！<br>例如使用『 tar -zcvfP tfile sfile』就是错误的写法，要写成<br>『 tar -zcvPf tfile sfile』才对喔！<br>-p ：使用原档案的原来属性（属性不会依据使用者而变）<br>-P ：可以使用绝对路径来压缩！<br>-N ：比后面接的日期(yyyy/mm/dd)还要新的才会被打包进新建的档案中！<br>–exclude FILE：在压缩的过程中，不要将 FILE 打包！<br>范例：<br>范例一：将整个 /etc 目录下的档案全部打包成为 /tmp/etc.tar<br>[root@linux ~]# tar -cvf /tmp/etc.tar /etc &lt;==仅打包，不压缩！<br>[root@linux ~]# tar -zcvf /tmp/etc.tar.gz /etc &lt;==打包后，以 gzip 压缩<br>[root@linux ~]# tar -jcvf /tmp/etc.tar.bz2 /etc &lt;==打包后，以 bzip2 压缩</p><h1 id="特别注意，在参数-f-之后的档案档名是自己取的，我们习惯上都用-tar-来作为辨识。"><a href="#特别注意，在参数-f-之后的档案档名是自己取的，我们习惯上都用-tar-来作为辨识。" class="headerlink" title="特别注意，在参数 f 之后的档案档名是自己取的，我们习惯上都用 .tar 来作为辨识。"></a>特别注意，在参数 f 之后的档案档名是自己取的，我们习惯上都用 .tar 来作为辨识。</h1><h1 id="如果加-z-参数，则以-tar-gz-或-tgz-来代表-gzip-压缩过的-tar-file-～"><a href="#如果加-z-参数，则以-tar-gz-或-tgz-来代表-gzip-压缩过的-tar-file-～" class="headerlink" title="如果加 z 参数，则以 .tar.gz 或 .tgz 来代表 gzip 压缩过的 tar file ～"></a>如果加 z 参数，则以 .tar.gz 或 .tgz 来代表 gzip 压缩过的 tar file ～</h1><h1 id="如果加-j-参数，则以-tar-bz2-来作为附档名啊～"><a href="#如果加-j-参数，则以-tar-bz2-来作为附档名啊～" class="headerlink" title="如果加 j 参数，则以 .tar.bz2 来作为附档名啊～"></a>如果加 j 参数，则以 .tar.bz2 来作为附档名啊～</h1><h1 id="上述指令在执行的时候，会显示一个警告讯息："><a href="#上述指令在执行的时候，会显示一个警告讯息：" class="headerlink" title="上述指令在执行的时候，会显示一个警告讯息："></a>上述指令在执行的时候，会显示一个警告讯息：</h1><h1 id="『tar-Removing-leading-‘-from-member-names』那是关于绝对路径的特殊设定。"><a href="#『tar-Removing-leading-‘-from-member-names』那是关于绝对路径的特殊设定。" class="headerlink" title="『tar: Removing leading `/‘ from member names』那是关于绝对路径的特殊设定。"></a>『tar: Removing leading `/‘ from member names』那是关于绝对路径的特殊设定。</h1><p>范例二：查阅上述 /tmp/etc.tar.gz 档案内有哪些档案？<br>[root@linux ~]# tar -ztvf /tmp/etc.tar.gz</p><h1 id="由于我们使用-gzip-压缩，所以要查阅该-tar-file-内的档案时，"><a href="#由于我们使用-gzip-压缩，所以要查阅该-tar-file-内的档案时，" class="headerlink" title="由于我们使用 gzip 压缩，所以要查阅该 tar file 内的档案时，"></a>由于我们使用 gzip 压缩，所以要查阅该 tar file 内的档案时，</h1><h1 id="就得要加上-z-这个参数了！这很重要的！"><a href="#就得要加上-z-这个参数了！这很重要的！" class="headerlink" title="就得要加上 z 这个参数了！这很重要的！"></a>就得要加上 z 这个参数了！这很重要的！</h1><p>范例三：将 /tmp/etc.tar.gz 档案解压缩在 /usr/local/src 底下<br>[root@linux ~]# cd /usr/local/src<br>[root@linux src]# tar -zxvf /tmp/etc.tar.gz</p><h1 id="在预设的情况下，我们可以将压缩档在任何地方解开的！以这个范例来说，"><a href="#在预设的情况下，我们可以将压缩档在任何地方解开的！以这个范例来说，" class="headerlink" title="在预设的情况下，我们可以将压缩档在任何地方解开的！以这个范例来说，"></a>在预设的情况下，我们可以将压缩档在任何地方解开的！以这个范例来说，</h1><h1 id="我先将工作目录变换到-usr-local-src-底下，并且解开-tmp-etc-tar-gz-，"><a href="#我先将工作目录变换到-usr-local-src-底下，并且解开-tmp-etc-tar-gz-，" class="headerlink" title="我先将工作目录变换到 /usr/local/src 底下，并且解开 /tmp/etc.tar.gz ，"></a>我先将工作目录变换到 /usr/local/src 底下，并且解开 /tmp/etc.tar.gz ，</h1><h1 id="则解开的目录会在-usr-local-src-etc-呢！另外，如果您进入-usr-local-src-etc"><a href="#则解开的目录会在-usr-local-src-etc-呢！另外，如果您进入-usr-local-src-etc" class="headerlink" title="则解开的目录会在 /usr/local/src/etc 呢！另外，如果您进入 /usr/local/src/etc"></a>则解开的目录会在 /usr/local/src/etc 呢！另外，如果您进入 /usr/local/src/etc</h1><h1 id="则会发现，该目录下的档案属性与-etc-可能会有所不同喔！"><a href="#则会发现，该目录下的档案属性与-etc-可能会有所不同喔！" class="headerlink" title="则会发现，该目录下的档案属性与 /etc/ 可能会有所不同喔！"></a>则会发现，该目录下的档案属性与 /etc/ 可能会有所不同喔！</h1><p>范例四：在 /tmp 底下，我只想要将 /tmp/etc.tar.gz 内的 etc/passwd 解开而已<br>[root@linux ~]# cd /tmp<br>[root@linux tmp]# tar -zxvf /tmp/etc.tar.gz etc/passwd</p><h1 id="我可以透过-tar-ztvf-来查阅-tarfile-内的文件名称，如果单只要一个档案，"><a href="#我可以透过-tar-ztvf-来查阅-tarfile-内的文件名称，如果单只要一个档案，" class="headerlink" title="我可以透过 tar -ztvf 来查阅 tarfile 内的文件名称，如果单只要一个档案，"></a>我可以透过 tar -ztvf 来查阅 tarfile 内的文件名称，如果单只要一个档案，</h1><h1 id="就可以透过这个方式来下达！注意到！-etc-tar-gz-内的根目录-是被拿掉了！"><a href="#就可以透过这个方式来下达！注意到！-etc-tar-gz-内的根目录-是被拿掉了！" class="headerlink" title="就可以透过这个方式来下达！注意到！ etc.tar.gz 内的根目录 / 是被拿掉了！"></a>就可以透过这个方式来下达！注意到！ etc.tar.gz 内的根目录 / 是被拿掉了！</h1><p>范例五：将 /etc/ 内的所有档案备份下来，并且保存其权限！<br>[root@linux ~]# tar -zcvpf /tmp/etc.tar.gz /etc</p><h1 id="这个-p-的属性是很重要的，尤其是当您要保留原本档案的属性时！"><a href="#这个-p-的属性是很重要的，尤其是当您要保留原本档案的属性时！" class="headerlink" title="这个 -p 的属性是很重要的，尤其是当您要保留原本档案的属性时！"></a>这个 -p 的属性是很重要的，尤其是当您要保留原本档案的属性时！</h1><p>范例六：在 /home 当中，比 2005/06/01 新的档案才备份<br>[root@linux ~]# tar -N ‘2005/06/01’ -zcvf home.tar.gz /home<br>范例七：我要备份 /home, /etc ，但不要 /home/dmtsai<br>[root@linux ~]# tar –exclude /home/dmtsai -zcvf myfile.tar.gz /home/* /etc<br>范例八：将 /etc/ 打包后直接解开在 /tmp 底下，而不产生档案！<br>[root@linux ~]# cd /tmp<br>[root@linux tmp]# tar -cvf - /etc | tar -xvf -</p><h1 id="这个动作有点像是-cp-r-etc-tmp-啦～依旧是有其有用途的！"><a href="#这个动作有点像是-cp-r-etc-tmp-啦～依旧是有其有用途的！" class="headerlink" title="这个动作有点像是 cp -r /etc /tmp 啦～依旧是有其有用途的！"></a>这个动作有点像是 cp -r /etc /tmp 啦～依旧是有其有用途的！</h1><h1 id="要注意的地方在于输出档变成-而输入档也变成-，又有一个-存在～"><a href="#要注意的地方在于输出档变成-而输入档也变成-，又有一个-存在～" class="headerlink" title="要注意的地方在于输出档变成 - 而输入档也变成 - ，又有一个 | 存在～"></a>要注意的地方在于输出档变成 - 而输入档也变成 - ，又有一个 | 存在～</h1><h1 id="这分别代表-standard-output-standard-input-与管线命令啦！"><a href="#这分别代表-standard-output-standard-input-与管线命令啦！" class="headerlink" title="这分别代表 standard output, standard input 与管线命令啦！"></a>这分别代表 standard output, standard input 与管线命令啦！</h1><h1 id="这部分我们会在-Bash-shell-时，再次提到这个指令跟大家再解释啰！"><a href="#这部分我们会在-Bash-shell-时，再次提到这个指令跟大家再解释啰！" class="headerlink" title="这部分我们会在 Bash shell 时，再次提到这个指令跟大家再解释啰！"></a>这部分我们会在 Bash shell 时，再次提到这个指令跟大家再解释啰！</h1><p>这是一个多用途的压缩指令！刚刚我们提到的 compress 与 gzip 是可以适用在一个档案的压缩上面， 但是如果是要将一个目录压缩成一个档案呢？！这时该如何是好？！呵呵！ tar 就派上用场了！ tar 可以将整个目录或者是指定的档案都整合成一个档案！例如上面的范例一，他可以将 /etc 底下的档案全部整合成一个档案！同时， tar 可以配合 gzip (这个 gzip 的功能已经已经附加上 tar 里面去了) ，同时整合并压缩！<br>• 绝对路径与权限的问题<br>另外，需要注意的是，在使用的参数方面，有还有几个有用的参数需要来了解一番，亦即是 -p 与 -P 这两个！在我们的范例一当中，有提到一个警告讯息，那就是『 tar: Removing leading `/‘ from member names』 意思是说， tar 将 /etc 目录的那个 / 拿掉了！这是因为担心未来你在解开压缩的时候，会产生一些困扰， 因为在 tar 里面的档案如果是具有『绝对路径』的话，那么你解开的档案将会『一定』在该路径下也就是 /etc，而不是相对路径 (这里请用心的想一想！) 。 这样子的最大困扰是，万一有人拿走了你的这个档案，并且将该档案在他的系统上面解开！万一他的系统上面正巧也有 /etc 这个目录 (那当然是一定有的啊！)，哈哈！他的档案就会『正巧』被覆盖了！ 所以啰，在预设的情况中，如果是以『绝对路径』来建立打包档案，那么 tar 将会自动的将 / 拿掉！这是为了刚刚说明的『安全』为前提所做的默认值。好了！但是你就是要以绝对路径来建立打包的档案！那么就<br>加入 -P 这个参数吧 (请注意！是大写字符) ！这样就可以啦！<br>VIM退出命令<br>注意：这些命令前面都有一个冒号：<br>当编辑完文档，准备退出Vi返回到shell时，能够使用以下几种方法之一。<br>在命令模式中，连按两次大写字母Z，若当前编辑的文档曾被修改过，则Vi保存该文档后退出，返回到shell；若当前编辑的文档没被修改过，则Vi直接退出, 返回到shell。<br>在末行模式下，输入命令<br>:w<br>Vi保存当前编辑文档，但并不退出，而是继续等待用户输入命令。在使用w命令时，能够再给编辑文档起一个新的文档名。<br>:w newfile<br>此时Vi将把当前文档的内容保存到指定的newfile中，而原有文档保持不变。若newfile是个已存在的文档，则Vi在显示窗口的状态行给出提示信息：<br>File exists （use ! to override）<br>此时，若用户真的希望用文档的当前内容替换newfile中原有内容，可使用命令<br>:w! newfile<br>否则可选择另外的文档名来保存当前文档。<br>在末行模式下，输入命令<br>:q<br>系统退出Vi返回到shell。若在用此命令退出Vi时，编辑文档没有被保存，则Vi在显示窗口的最末行显示如下信息：<br>No write since last change （use ! to overrides）<br>提示用户该文档被修改后没有保存，然后Vi并不退出，继续等待用户命令。若用户就是不想保存被修改后的文档而要强行退出Vi时，可使用命令<br>:q!<br>Vi放弃所作修改而直接退到shell下。</p><p>在末行模式下，输入命令<br>:wq<br>Vi将先保存文档，然后退出Vi返回到shell。<br>在末行模式下，输入命令<br>:x<br>该命令的功能同命令模式下的ZZ命令功能相同。<br>vi：常用命令<br>如前所述，所谓的命令列或命令模式，就是在最下面一行没有显示 『–INSERT–』或者『–REPLACE–』 字样的时候。通常在命令列中的指令有下面几种：（注意，当按下 『:』 时，光标会自动移动到屏幕的最下面一行！）<br>一般模式： 移动光标的方法<br>h 或 向左方向键(←)<br>光标向左移动一个字符<br>j 或 向下方向键(↓)<br>光标向下移动一个字符<br>k 或 向上方向键(↑)<br>光标向上移动一个字符<br>l 或 向右方向键(→)<br>光标向右移动一个字符<br>如果想要进行多次移动的话，例如向下移动 30 行，可以使用 “30j” 或 “30↓” 的组合按键， 亦即加上想要进行的次数(数字)后，按下动作即可！<br>[Ctrl] + [f]<br>屏幕『向下』移动一页，相当于 [Page Down]按键 (常用)<br>[Ctrl] + [b]<br>屏幕『向上』移动一页，相当于 [Page Up] 按键 (常用)<br>[Ctrl] + [d]<br>屏幕『向下』移动半页<br>[Ctrl] + [u]<br>屏幕『向上』移动半页<br>+<br>光标移动到非空格符的下一列<br>-<br>光标移动到非空格符的上一列<br>n<space><br>那个 n 表示『数字』，例如 20 。按下数字后再按空格键，光标会向右移动这一行的 n 个字符。例如 20<space> 则光标会向后面移动 20 个字符距离。<br>0<br>这是数字『 0 』：移动到这一行的最前面字符处 (常用)<br>$<br>移动到这一行的最后面字符处(常用)<br>H<br>光标移动到这个屏幕的最上方那一行<br>M<br>光标移动到这个屏幕的中央那一行<br>L<br>光标移动到这个屏幕的最下方那一行<br>G<br>移动到这个档案的最后一行(常用)<br>nG<br>n 为数字。移动到这个档案的第 n 行。例如 20G 则会移动到这个档案的第 20 行(可配合 :set nu)<br>gg<br>移动到这个档案的第一行，相当于 1G 啊！ (常用)<br>n<enter><br>n 为数字。光标向下移动 n 行(常用)<br>一般模式： 搜寻与取代<br>/word<br>向光标之下寻找一个字符串名称为 word 的字符串。例如要在档案内搜寻 vbird 这个字符串，就输入 /vbird 即可！ (常用)<br>?word<br>向光标之上寻找一个字符串名称为 word 的字符串。<br>n<br>这个 n 是英文按键。代表『重复前一个搜寻的动作』的意思。举例来说， 如果刚刚我们执行 /vbird 去向下搜寻 vbird 这个字符串，则按下 n 后，会向下继续搜寻下一个名称为 vbird 的字符串。如果是执行 ?vbird 的话，那么按下 n 则会向上继续搜寻名称为 vbird 的字符串！<br>N<br>这个 N 是英文按键。与 n 刚好相反，为『反向』进行前一个搜寻动作。 例如 /vbird 后，按下 N 则表示『向上』搜寻 vbird 。<br>:n1,n2s/word1/word2/g<br>n1 与 n2 为数字。在第 n1 与 n2 行之间寻找 word1 这个字符串，并将该字符串取代为 word2 ！举例来说，在 100 到 200 行之间搜寻 vbird 并取代为 VBIRD 则： 『:100,200s/vbird/VBIRD/g』。(常用)<br>:1,$s/word1/word2/g<br>从第一行到最后一行寻找 word1 字符串，并将该字符串取代为 word2 ！(常用)<br>:1,$s/word1/word2/gc<br>从第一行到最后一行寻找 word1 字符串，并将该字符串取代为 word2 ！且在取代前显示提示字符给使用者确认 (conform) 是否需要取代！(常用)<br>一般模式： 删除、复制与贴上<br>x, X<br>在一行字当中，x 为向后删除一个字符 (相当于 [del] 按键)， X 为向前删除一个字符(相当于 [backspace] 亦即是退格键) (常用)<br>nx<br>n 为数字，连续向后删除 n 个字符。举例来说，我要连续删除 10 个字符， 『10x』。<br>dd<br>删除游标所在的那一整列(常用)<br>ndd<br>n 为数字。删除光标所在的向下 n 列，例如 20dd 则是删除 20 列 (常用)<br>d1G<br>删除光标所在到第一行的所有数据<br>dG<br>删除光标所在到最后一行的所有数据<br>d$<br>删除游标所在处，到该行的最后一个字符<br>d0<br>那个是数字的 0 ，删除游标所在处，到该行的最前面一个字符<br>yy<br>复制游标所在的那一行(常用)<br>nyy<br>n 为数字。复制光标所在的向下 n 列，例如 20yy 则是复制 20 列(常用)<br>y1G<br>复制光标所在列到第一列的所有数据<br>yG<br>复制光标所在列到最后一列的所有数据<br>y0<br>复制光标所在的那个字符到该行行首的所有数据<br>y$<br>复制光标所在的那个字符到该行行尾的所有数据<br>p, P<br>p 为将已复制的数据在光标下一行贴上，P 则为贴在游标上一行！ 举例来说，我目前光标在第 20 行，且已经复制了 10 行数据。则按下 p 后， 那 10 行数据会贴在原本的 20 行之后，亦即由 21 行开始贴。但如果是按下 P 呢？ 那么原本的第 20 行会被推到变成 30 行。 (常用)<br>J<br>将光标所在列与下一列的数据结合成同一列<br>c<br>重复删除多个数据，例如向下删除 10 行，[ 10cj ]<br>u<br>复原前一个动作。(常用)<br>[Ctrl]+r<br>重做上一个动作。(常用)<br>这个 u 与 [Ctrl]+r 是很常用的指令！一个是复原，另一个则是重做一次～ 利用这两个功能按键，您的编辑，嘿嘿！很快乐的啦！<br>.<br>不要怀疑！这就是小数点！意思是重复前一个动作的意思。 如果您想要重复删除、重复贴上等等动作，按下小数点『.』就好了！ (常用)<br>进入编辑模式<br>i, I<br>插入：在目前的光标所在处插入输入之文字，已存在的文字会向后<br>退； 其中， i 为『从目前光标所在处插入』， I 为『在目前所在行的第一个非空格符处开始插入』。 (常用)<br>a, A<br>a 为『从目前光标所在的下一个字符处开始插入』， A 为『从光标所在行的最后一个字符处开始插入』。(常用)<br>o, O<br>这是英文字母 o 的大小写。o 为『在目前光标所在的下一行处插入新的一行』； O 为在目前光标所在处的上一行插入新的一行！(常用)<br>r, R<br>取代：r 会取代光标所在的那一个字符；R会一直取代光标所在的文字，直到按下 ESC 为止；(常用)<br>上面这些按键中，在 vi 画面的左下角处会出现『–INSERT–』或『–REPLACE–』的字样。 由名称就知道该动作了吧！！特别注意的是，我们上面也提过了，你想要在档案里面输入字符时， 一定要在左下角处看到 INSERT/REPLACE 才能输入喔！<br>Esc<br>退出编辑模式，回到一般模式中(常用)<br>指令列命令模式<br>:w<br>将编辑的数据写入硬盘档案中(常用)<br>:w!<br>若档案属性为『只读』时，强制写入该档案。不过，到底能不能写入， 还是跟您对该档案的档案权限有关啊！<br>:q<br>离开 vi (常用)<br>:q!<br>若曾修改过档案，又不想储存，使用 ! 为强制离开不储存档案。<br>注意一下啊，那个惊叹号 (!) 在 vi 当中，常常具有『强制』的意思～</enter></space></space></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;Linux-笔记&quot;&gt;&lt;a href=&quot;#Linux-笔记&quot; class=&quot;headerlink&quot; title=&quot;Linux 笔记&quot;&gt;&lt;/a&gt;Linux 笔记&lt;/h3&gt;&lt;p&gt;LINUX笔记：&lt;br&gt;最左边的 root 显示的是『目前使用者的账号』， 而 @ 之后接的
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Java多线程</title>
    <link href="http://yoursite.com/2018/03/13/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    <id>http://yoursite.com/2018/03/13/多线程/</id>
    <published>2018-03-13T12:08:18.019Z</published>
    <updated>2018-03-14T12:24:48.204Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Java实现多线程的几种方式："><a href="#Java实现多线程的几种方式：" class="headerlink" title="Java实现多线程的几种方式："></a>Java实现多线程的几种方式：</h3><blockquote><ol><li>继承Thread类，重写父类的run()方法</li><li>实现Runnable接口</li><li>使用ExecutorService、Callable、Future实现由返回结果的多线程<br></li></ol></blockquote><p>&nbsp;&nbsp;其中Thread类中实现了Runnable接口,并且启动线程的时候要用到start()方法，所有当我们实现Runnable接口的时候，需要创建一个Thread对象，来启动线程。带有返回值的线程是jdk1.5引入的新特性，实现Callable时需要重写call()方法，当启动线程的时候可以获取一个Future的对象，在这个对象上调用get()方法就可以获取到Callable任务返回的Object了。</p><h3 id="Callable和Future的了解"><a href="#Callable和Future的了解" class="headerlink" title="Callable和Future的了解"></a>Callable和Future的了解</h3><ol><li>Callable<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">@FunctionalInterface</span><br><span class="line">public interface Callable&lt;V&gt; &#123;</span><br><span class="line">    /**</span><br><span class="line">     * Computes a result, or throws an exception if unable to do so.</span><br><span class="line">     *</span><br><span class="line">     * @return computed result</span><br><span class="line">     * @throws Exception if unable to compute a result</span><br><span class="line">     */</span><br><span class="line">    V call() throws Exception;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>&nbsp;&nbsp;从源码中看，我们可以知道call()方法有返回值并且可以抛出异常，callable常与ExecutorService配合来使用，启动线程调用sumbit()方法即可</p><ol><li>Future<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">public interface Future&lt;V&gt; &#123;</span><br><span class="line">/**</span><br><span class="line">*取消任务，如果取消任务成功则返回true</span><br><span class="line">*/</span><br><span class="line">    boolean cancel(boolean mayInterruptIfRunning);</span><br><span class="line">/**</span><br><span class="line">*表示任务是否被取消成功，如果在任务正常完成前被取消成功，则返回 true。</span><br><span class="line">*/</span><br><span class="line">    boolean isCancelled();</span><br><span class="line">/**</span><br><span class="line">*表示任务是否已经完成，若任务完成，则返回true；</span><br><span class="line">*/</span><br><span class="line">    boolean isDone();</span><br><span class="line">/**</span><br><span class="line">*用来获取执行结果，这个方法会产生阻塞，会一直等到任务执行完毕才返回；</span><br><span class="line">*/</span><br><span class="line">    V get() throws InterruptedException, ExecutionException;</span><br><span class="line">/**</span><br><span class="line">*用来获取执行结果，如果在指定时间内，还没获取到结果，就直接返回null。</span><br><span class="line">*/</span><br><span class="line">    V get(long timeout, TimeUnit unit)</span><br><span class="line">        throws InterruptedException, ExecutionException, TimeoutException;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>&nbsp;&nbsp;由源码可以看出来Future一共有三种功能：1、判断任务是否完成，2、手动取消任务，3、获取任务执行结构</p><h3 id="synchronized关键字的用法"><a href="#synchronized关键字的用法" class="headerlink" title="synchronized关键字的用法"></a>synchronized关键字的用法</h3><p>synchronized 是 java语言的关键字，当它用来修饰一个方法或者一个代码块的时候，能够保证在同一时刻最多只有一个线程执行该段代码。<br></p><ol><li>当两个并发线程访问同一个对象中的这个synchronized(this)同步代码块时，一个时间内只能有一个线程得到执行。另一个线程必须等待当前线程执行完这个代码块以后才能执行该代码块。</li><li>当一个线程访问一个对象的synchronized(this)同步代码块时，另一个线程仍然可以访问该对象中的非synchronized(this)同步代码块。</li><li>当一个线程访问对象的一个synchronized(this)同步代码块时，其他线程对象中所有其它synchronized(this)同步代码块的访问将被阻塞。</li><li>当一个线程访问对象的一个synchronized(this)同步代码块时，它就获得了这个对象的对象锁。结果，其它线程对该对象所有同步代码部分的访问都被暂时阻塞。<h3 id="synchronized关键字的缺点"><a href="#synchronized关键字的缺点" class="headerlink" title="synchronized关键字的缺点"></a>synchronized关键字的缺点</h3>&nbsp;&nbsp;当多个线程尝试获取锁时，未获取到锁的线程会不断的尝试获取锁，而不会发生中断，这样会造成性能消耗。<h3 id="Lock接口中的实现类"><a href="#Lock接口中的实现类" class="headerlink" title="Lock接口中的实现类"></a>Lock接口中的实现类</h3>&nbsp;&nbsp;Lock接口有三个实现类，一个是ReentrantLock,另两个是ReentrantReadWriteLock类中的两个静态内部类ReadLock和WriteLock</li></ol><h3 id="java-线程的几种状态"><a href="#java-线程的几种状态" class="headerlink" title="java 线程的几种状态"></a>java 线程的几种状态</h3><ul><li>NEW 状态是指线程刚创建, 尚未启动</li><li>RUNNABLE 状态是线程正在正常运行中, 当然可能会有某种耗时计算/IO等待的操作/CPU时间片切换等, 这个状态下发生的等待一般是其他系统资源, 而不是锁, Sleep等</li><li>BLOCKED  这个状态下, 是在多个线程有同步操作的场景, 比如正在等待另一个线程的synchronized 块的执行释放, 或者可重入的 synchronized块里别人调用wait() 方法, 也就是这里是线程在等待进入临界区</li><li>WAITING  这个状态下是指线程拥有了某个锁之后, 调用了他的wait()方法, 等待其他线程/锁拥有者调用 notify / notifyAll 一遍该线程可以继续下一步操作, 这里要区分 BLOCKED 和 WATING 的区别, 一个是在临界点外面等待进入, 一个是在理解点里面wait等待别人notify, 线程调用了join方法 join了另外的线程的时候, 也会进入WAITING状态, 等待被他join的线程执行结束</li><li>TIMED_WAITING  这个状态就是有限的(时间限制)的WAITING, 一般出现在调用wait(long), join(long)等情况下, 另外一个线程sleep后, 也会进入TIMED_WAITING状态</li><li>TERMINATED 这个状态下表示 该线程的run方法已经执行完毕了, 基本上就等于死亡了(当时如果线程被持久持有, 可能不会被回收)<h3 id="sleep和wait的区别"><a href="#sleep和wait的区别" class="headerlink" title="sleep和wait的区别"></a>sleep和wait的区别</h3></li><li>每个对象都有一个锁来控制同步访问，Synchronized关键字可以和对象的锁交互，来实现同步方法或同步块。sleep()方法正在执行的线程主动让出CPU（然后CPU就可以去执行其他任务），在sleep指定时间后CPU再回到该线程继续往下执行(注意：sleep方法只让出了CPU，而并不会释放同步资源锁！！！)；wait()方法则是指当前线程让自己暂时退让出同步资源锁，以便其他正在等待该资源的线程得到该资源进而运行，只有调用了notify()方法，之前调用wait()的线程才会解除wait状态，可以去参与竞争同步资源锁，进而得到执行。（注意：notify的作用相当于叫醒睡着的人，而并不会给他分配任务，就是说notify只是让之前调用wait的线程有权利重新参与线程的调度）；</li><li>sleep()方法可以在任何地方使用；wait()方法则只能在同步方法或同步块中使用；</li><li>sleep()是线程线程类（Thread）的方法，调用会暂停此线程指定的时间，但监控依然保持，不会释放对象锁，到时间自动恢复；wait()是Object的方法，调用会放弃对象锁，进入等待队列，待调用notify()/notifyAll()唤醒指定的线程或者所有线程，才会进入锁池，不再次获得对象锁才会进入运行状态；<h3 id="notify和notifyall的区别"><a href="#notify和notifyall的区别" class="headerlink" title="notify和notifyall的区别"></a>notify和notifyall的区别</h3>当一个线程进入wait之后，就必须等其他线程notify/notifyall,使用notifyall,可以唤醒所有处于wait状态的线程，使其重新进入锁的争夺队列中，而notify只能唤醒一个。注意，任何时候只有一个线程可以获得锁，也就是说只有一个线程可以运行synchronized 中的代码，notifyall只是让处于wait的线程重新拥有锁的争夺权，但是只会有一个获得锁并执行。<h3 id="线程池常用参数"><a href="#线程池常用参数" class="headerlink" title="线程池常用参数"></a>线程池常用参数</h3></li><li>corePoolSize<br>  在创建了线程池后，默认情况下，线程池中并没有任何线程，而是等待有任务到来才创建线程去执行任务，（除非调用了prestartAllCoreThreads()或者prestartCoreThread()方法，从这2个方法的名字就可以看出，是预创建线程的意思，即在没有任务到来之前就创建corePoolSize个线程或者一个线程）。<br>  默认情况下，在创建了线程池后，线程池中的线程数为0，当有任务来之后，就会创建一个线程去执行任务，当线程池中的线程数目达到corePoolSize后，就会把到达的任务放到缓存队列当中。核心线程在allowCoreThreadTimeout被设置为true时会超时退出，默认情况下不会退出。</li><li>maxPoolSize<br>  当线程数大于或等于核心线程，且任务队列已满时，线程池会创建新的线程，直到线程数量达到maxPoolSize。如果线程数已等于maxPoolSize，且任务队列已满，则已超出线程池的处理能力，线程池会拒绝处理任务而抛出异常。</li><li>keepAliveTime<br>  当线程空闲时间达到keepAliveTime，该线程会退出，直到线程数量等于corePoolSize。如果allowCoreThreadTimeout设置为true，则所有线程均会退出直到线程数量为0。</li><li>allowCoreThreadTimeout<br>  是否允许核心线程空闲退出，默认值为false。</li><li>queueCapacity<br>  任务队列容量。从maxPoolSize的描述上可以看出，任务队列的容量会影响到线程的变化，因此任务队列的长度也需要恰当的设置。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;Java实现多线程的几种方式：&quot;&gt;&lt;a href=&quot;#Java实现多线程的几种方式：&quot; class=&quot;headerlink&quot; title=&quot;Java实现多线程的几种方式：&quot;&gt;&lt;/a&gt;Java实现多线程的几种方式：&lt;/h3&gt;&lt;blockquote&gt;
&lt;ol&gt;
&lt;li
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>oracle学习笔记</title>
    <link href="http://yoursite.com/2018/03/12/oracle/"/>
    <id>http://yoursite.com/2018/03/12/oracle/</id>
    <published>2018-03-12T15:52:38.973Z</published>
    <updated>2018-03-13T12:25:14.861Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一、ORACLE常见数据库优化手段"><a href="#一、ORACLE常见数据库优化手段" class="headerlink" title="一、ORACLE常见数据库优化手段"></a>一、ORACLE常见数据库优化手段</h3><ol><li>SQL语句尽量用大写的</li><li>使用表的别名</li><li>选择最有效率的表名顺序(只在基于规则的优化器(RBO)中有效)ORACLE 的解析器按照从右到左的顺序处理FROM子句中的表名，FROM子句中写在最后的表(基础表也称为驱动表,driving table)将被最先处理，在FROM子句中包含多个表的情况下,必须选择记录条数最少的表作为基础表。如果有3个以上的表连接查询, 那就需要选择交叉表(intersection table)作为基础表, 交叉表是指那个被其他表所引用的表。</li><li>WHERE子句中的连接顺序:ORACLE采用自下而上的顺序解析WHERE子句,根据这个原理,表之间的连接必须写在其他WHERE条件之前, 那些可以过滤掉最大数量记录的条件必须写在WHERE子句的末尾。</li><li>SELECT子句中避免使用 <em> ：因为oracle内部会将</em>转变为所有列名</li><li>减少访问数据库的次数：ORACLE在内部执行了许多工作: 解析SQL语句,估算索引的利用率,绑定变量,读数据块等。</li><li>整合简单、无关联的数据库访问：如果有几个简单的数据库查询语句,可以整合到一个查询中(即使它们之间没有关系)。</li><li>用&gt;=替代&gt;</li><li>避免在索引列上使用NOT：NOT会产生在和在索引列上使用函数相同的影响。当ORACLE遇到NOT,就会停止使用索引转而执行全表扫描。</li><li>WHERE子句: 某些SELECT 语句中的WHERE子句不使用索引。(1)’!=’不走索引。索引只能告诉我们什么存在于表中, 而不能告诉你什么不在表中。(2)’||’是字符连接函数。就象其他函数那样, 停用了索引。(3)’+’是数学函数。和其他数学函数一样, 停用了索引。(4)相同的索引列不能互相比较,这将会启用全表扫描。</li></ol><h3 id="二、索引的优缺点"><a href="#二、索引的优缺点" class="headerlink" title="二、索引的优缺点"></a>二、索引的优缺点</h3><ul><li>优点：1）通过创建唯一性索引，可以保证数据库表中每一行数据的唯一性。<br>2）可以大大加快数据的检索速度，这也是创建索引的最主要的原因。<br>3）可以加速表和表之间的连接，特别是在实现数据的参考完整性方面特别有意义。<br>4）在使用分组和排序 子句进行数据检索时，同样可以显著减少查询中分组和排序的时间。<br>5）通过使用索引，可以在查询的过程中，使用优化隐藏器，提高系统的性能。</li><li>缺点：1）创建索引和维护索引要耗费时间，这种时间随着数据量的增加而增加。<br>2）索引需要占物理空间，除了数据表占数据空间之外，每一个索引还要占一定的物理空间，如果要建立聚簇索引，那么需要的空间就会更大。<br>3）当对表中的数据进行增加、删除和修改的时候，索引也要动态的维护，这样就降低了数据的维护速度。</li><li>应用：1）在经常需要搜索的列上，可以加快搜索的速度；<br>2）在作为主键的列上，强制该列的唯一性和组织表中数据的排列结构；<br>3）在经常用在连接的列上，这 些列主要是一些外键，可以加快连接的速度；<br>4）在经常需要根据范围进行搜索的列上创建索引，因为索引已经排序，其指定的范围是连续的；<br>5）在经常需要排序的列上创 建索引，因为索引已经排序，这样查询可以利用索引的排序，加快排序查询时间； 搜索<br>6）在经常使用在WHERE子句中的列上面创建索引，加快条件的判断速度。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;一、ORACLE常见数据库优化手段&quot;&gt;&lt;a href=&quot;#一、ORACLE常见数据库优化手段&quot; class=&quot;headerlink&quot; title=&quot;一、ORACLE常见数据库优化手段&quot;&gt;&lt;/a&gt;一、ORACLE常见数据库优化手段&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;SQL语
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Java序列化</title>
    <link href="http://yoursite.com/2018/03/11/serialization/"/>
    <id>http://yoursite.com/2018/03/11/serialization/</id>
    <published>2018-03-11T15:31:11.466Z</published>
    <updated>2018-03-13T11:56:25.561Z</updated>
    
    <content type="html"><![CDATA[<p>###一、Java序列化简介<br>&emsp;&emsp;Java 对象序列化是 JDK 1.1 中引入的一组开创性特性之一，用于作为一种将 Java 对象的状态转换为字节数组，以便存储或传输的机制，以后，仍可以将字节数组转换回 Java 对象原有的状态。<br>实际上，序列化的思想是 “冻结” 对象状态，传输对象状态（写到磁盘、通过网络传输等等），然后 “解冻” 状态，重新获得可用的 Java 对象。所有这些事情的发生有点像是魔术，这要归功于 ObjectInputStream/ObjectOutputStream 类、完全保真的元数据以及程序员愿意用 Serializable 标识接口标记他们的类，从而 “参与” 这个过程</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;###一、Java序列化简介&lt;br&gt;&amp;emsp;&amp;emsp;Java 对象序列化是 JDK 1.1 中引入的一组开创性特性之一，用于作为一种将 Java 对象的状态转换为字节数组，以便存储或传输的机制，以后，仍可以将字节数组转换回 Java 对象原有的状态。&lt;br&gt;实际上，
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>HashMap</title>
    <link href="http://yoursite.com/2018/03/07/java/"/>
    <id>http://yoursite.com/2018/03/07/java/</id>
    <published>2018-03-07T15:21:38.028Z</published>
    <updated>2018-03-12T12:40:04.145Z</updated>
    
    <content type="html"><![CDATA[<h2 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h2><h3 id="一、HashMap实现原理"><a href="#一、HashMap实现原理" class="headerlink" title="一、HashMap实现原理"></a>一、HashMap实现原理</h3><p>&emsp;&emsp;HashMap是基于哈希表实现的，每一个元素都是key-value对，其内部是通过单链表结构解决内部冲突问题,当容量不足的时候，会通过自动增长来解决这个问题<br><br>&emsp;&emsp;HashMap是非线程安全的，所以用于单线程环境下,多线程环境下可以采用concurrent并发包下的concurrentHashMap。<br><br>&emsp;&emsp;HashMap实现了Serializable接口，因此它支持序列化，实现了Cloneable接口，能被克隆。<br><br>&emsp;&emsp;HashMap由数组+链表组成的，数组是HashMap的主体，链表则是主要为了解决哈希冲突而存在的，如果定位到的数组位置不含链表（当前entry的next指向null）,那么对于查找，添加等操作很快，仅需一次寻址即可；如果定位到的数组包含链表，对于添加操作，其时间复杂度依然为O(1)，因为最新的Node会插入链表头部，只需要简单的改变引用链，而对于查找操作来讲，此时就需要遍历链表，然后通过key对象的equals方法逐一对比。所以从性能方面考虑，HashMap中的链表出现越少，性能才会越好。<br><br>&emsp;&emsp;链表中节点的数据结构：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">// Node是单向链表。    </span><br><span class="line">// 它是 “HashMap链式存储法”对应的链表。    </span><br><span class="line">// 它实现了Map.Entry 接口，即实现getKey(), getValue(), setValue(V value), equals(Object o), hashCode()这些函数    </span><br><span class="line">static class Node&lt;K,V&gt; implements Map.Entry&lt;K,V&gt; &#123;</span><br><span class="line">       final int hash;</span><br><span class="line">       final K key;</span><br><span class="line">       V value;</span><br><span class="line">       Node&lt;K,V&gt; next;</span><br><span class="line"></span><br><span class="line">       Node(int hash, K key, V value, Node&lt;K,V&gt; next) &#123;</span><br><span class="line">           this.hash = hash;</span><br><span class="line">           this.key = key;</span><br><span class="line">           this.value = value;</span><br><span class="line">           this.next = next;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       public final K getKey()        &#123; return key; &#125;</span><br><span class="line">       public final V getValue()      &#123; return value; &#125;</span><br><span class="line">       public final String toString() &#123; return key + &quot;=&quot; + value; &#125;</span><br><span class="line"></span><br><span class="line">       public final int hashCode() &#123;</span><br><span class="line">           return Objects.hashCode(key) ^ Objects.hashCode(value);</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       public final V setValue(V newValue) &#123;</span><br><span class="line">           V oldValue = value;</span><br><span class="line">           value = newValue;</span><br><span class="line">           return oldValue;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       public final boolean equals(Object o) &#123;</span><br><span class="line">           if (o == this)</span><br><span class="line">               return true;</span><br><span class="line">           if (o instanceof Map.Entry) &#123;</span><br><span class="line">               Map.Entry&lt;?,?&gt; e = (Map.Entry&lt;?,?&gt;)o;</span><br><span class="line">               if (Objects.equals(key, e.getKey()) &amp;&amp;</span><br><span class="line">                   Objects.equals(value, e.getValue()))</span><br><span class="line">                   return true;</span><br><span class="line">           &#125;</span><br><span class="line">           return false;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp; 它的结构元素除了key、value、hash外，还有next，next指向下一个节点。另外，这里覆写了equals和hashCode方法来保证键值对的独一无二。</p><h3 id="二、HashMap是怎么扩容的，简介加载因子"><a href="#二、HashMap是怎么扩容的，简介加载因子" class="headerlink" title="二、HashMap是怎么扩容的，简介加载因子"></a>二、HashMap是怎么扩容的，简介加载因子</h3><p>&emsp;&emsp;HashMap共有四个构造方法。构造方法中提到了两个很重要的参数：初始容量和加载因子。这两个参数是影响HashMap性能的重要参数，其中容量表示哈希表中槽的数量（即哈希数组的长度），初始容量是创建哈希表时的容量（从构造函数中可以看出，如果不指明，则默认为16），加载因子是哈希表在其容量自动增加之前可以达到多满的一种尺度，当哈希表中的条目数超出了加载因子与当前容量的乘积时，则要对该哈希表进行 resize 操作（即扩容）。<br>&emsp;&emsp;如果加载因子越大，对空间的利用更充分，但是查找效率会降低（链表长度会越来越长）；如果加载因子太小，那么表中的数据将过于稀疏（很多空间还没用，就开始扩容了），对空间造成严重浪费。如果我们在构造方法中不指定，则系统默认加载因子为0.75，这是一个比较理想的值，一般情况下我们是无需修改的。另外无论我们指定的容量为多少，构造方法都会将实际容量设为不小于指定容量的2的次方的一个数，且最大值不能超过2的30次方</p><h3 id="三、jdk8对hashmap做了什么优化"><a href="#三、jdk8对hashmap做了什么优化" class="headerlink" title="三、jdk8对hashmap做了什么优化"></a>三、jdk8对hashmap做了什么优化</h3><p>&emsp;&emsp;在JDK1.8版本中，对数据结构做了进一步的优化，引入了红黑树。而当链表长度太长（默认超过8）时，链表就转换为红黑树，利用红黑树快速增删改查的特点提高HashMap的性能，其中会用到红黑树的插入、删除、查找等算法</p><h3 id="四、HashMap在高并发下如果没有处理线程安全会有什么的安全隐患"><a href="#四、HashMap在高并发下如果没有处理线程安全会有什么的安全隐患" class="headerlink" title="四、HashMap在高并发下如果没有处理线程安全会有什么的安全隐患"></a>四、HashMap在高并发下如果没有处理线程安全会有什么的安全隐患</h3><p>&emsp;&emsp;HashMap事实上并非线程安全的，在高并发的情况下，是非常可能发生死循环的，由此造成CPU 100%，这是非常可怕的。所以在多线程的情况下，用HashMap是非常不妥当的行为，应采用线程安全类ConcurrentHashMap进行取代。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;HashMap&quot;&gt;&lt;a href=&quot;#HashMap&quot; class=&quot;headerlink&quot; title=&quot;HashMap&quot;&gt;&lt;/a&gt;HashMap&lt;/h2&gt;&lt;h3 id=&quot;一、HashMap实现原理&quot;&gt;&lt;a href=&quot;#一、HashMap实现原理&quot; class
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="http://yoursite.com/2018/02/26/hello-world/"/>
    <id>http://yoursite.com/2018/02/26/hello-world/</id>
    <published>2018-02-26T15:47:51.992Z</published>
    <updated>2018-02-28T12:44:24.504Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p><h3 id="Create-a-new-post-1"><a href="#Create-a-new-post-1" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server-1"><a href="#Run-server-1" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files-1"><a href="#Generate-static-files-1" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites-1"><a href="#Deploy-to-remote-sites-1" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p><h3 id="Create-a-new-post-2"><a href="#Create-a-new-post-2" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server-2"><a href="#Run-server-2" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files-2"><a href="#Generate-static-files-2" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites-2"><a href="#Deploy-to-remote-sites-2" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p><h3 id="Create-a-new-post-3"><a href="#Create-a-new-post-3" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server-3"><a href="#Run-server-3" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files-3"><a href="#Generate-static-files-3" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites-3"><a href="#Deploy-to-remote-sites-3" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.
      
    
    </summary>
    
    
  </entry>
  
</feed>
